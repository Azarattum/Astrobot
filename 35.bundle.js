(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{1085:function(e,t,n){"use strict";n.d(t,"a",(function(){return TileProgram}));var r=n(40);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TileProgram{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const o=Object(r.a)(this.rank),i=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}},1088:function(e,t,n){"use strict";n.d(t,"a",(function(){return TransformProgram}));
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class TransformProgram{constructor(e,t,n,r,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const u="nearest"===n?1:2;let a;switch(r){case"constant":a=1;break;case"reflect":a=2;break;case"wrap":a=3;break;case"nearest":a=4;break;default:a=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${a} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${u} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}},13:function(e,t,n){"use strict";n.d(t,"e",(function(){return u})),n.d(t,"f",(function(){return a})),n.d(t,"o",(function(){return s})),n.d(t,"m",(function(){return c})),n.d(t,"g",(function(){return l})),n.d(t,"E",(function(){return d})),n.d(t,"i",(function(){return h})),n.d(t,"D",(function(){return E})),n.d(t,"H",(function(){return g})),n.d(t,"k",(function(){return T})),n.d(t,"j",(function(){return p})),n.d(t,"l",(function(){return m})),n.d(t,"I",(function(){return x})),n.d(t,"h",(function(){return F})),n.d(t,"d",(function(){return _})),n.d(t,"r",(function(){return b})),n.d(t,"q",(function(){return A})),n.d(t,"c",(function(){return R})),n.d(t,"b",(function(){return O})),n.d(t,"F",(function(){return C})),n.d(t,"G",(function(){return U})),n.d(t,"n",(function(){return P})),n.d(t,"s",(function(){return B})),n.d(t,"t",(function(){return I})),n.d(t,"u",(function(){return S})),n.d(t,"A",(function(){return D})),n.d(t,"w",(function(){return v})),n.d(t,"p",(function(){return X})),n.d(t,"v",(function(){return k})),n.d(t,"x",(function(){return $})),n.d(t,"C",(function(){return G})),n.d(t,"y",(function(){return j})),n.d(t,"z",(function(){return W})),n.d(t,"B",(function(){return Y})),n.d(t,"a",(function(){return z}));var r=n(0),o=n(97),i=n(33);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){const n=t();return Object(r.de)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+t}}(e,t))}(e),n}function a(e){return!!(Object(r.de)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function s(e,t){return N(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function c(e,t){const n=N(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(u(e,()=>e.shaderSource(n,t)),u(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function l(e,t){const n=N(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(u(e,()=>e.shaderSource(n,t)),u(e,()=>e.compileShader(n)),Object(r.de)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw d(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const f=/ERROR: [0-9]+:([0-9]+):/g;function d(e,t){const n=f.exec(t);if(null==n)return console.log("Couldn't parse line number in error: "+t),void console.log(e);const o=+n[1],i=e.split("\n"),u=i.length.toString().length+2,a=i.map((e,t)=>r.Hf.rightPad((t+1).toString(),u)+e);let s=0;for(let e=0;e<a.length;e++)s=Math.max(a[e].length,s);const c=a.slice(0,o-1),l=a.slice(o-1,o),d=a.slice(o);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c "+r.Hf.rightPad(l[0],s),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function h(e){return N(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function E(e,t){if(u(e,()=>e.linkProgram(t)),!Object(r.de)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function g(e,t){if(u(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function T(e,t){const n=N(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return u(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),u(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function p(e,t){const n=N(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return u(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),u(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function m(e){return N(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function x(e,t){const n=Object(r.de)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function F(e){return N(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function _(e,t,n,r,o,i,a){const s=e.getAttribLocation(t,n);return-1!==s&&(u(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),u(e,()=>e.vertexAttribPointer(s,o,e.FLOAT,!1,i,a)),u(e,()=>e.enableVertexAttribArray(s)),!0)}function b(e,t,n){return N(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function A(e,t,n){return e.getUniformLocation(t,n)}function R(e,t,n,r){u(e,()=>function(e,t,n){L(e,n),u(e,()=>e.activeTexture(e.TEXTURE0+n)),u(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,r)),u(e,()=>e.uniform1i(n,r))}function O(e,t,n){u(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),u(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function C(e,t){u(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),u(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function U(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+t}}(e,t))}function N(e,t,n){const r=u(e,()=>t());if(null==r)throw new Error(n);return r}function L(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function P(e,t=2){return r.Hf.sizeFromShape(e.slice(0,e.length-t))}function B(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function I(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[P(e),...B(e)]),t}function S(e,t=!1){let n=Object(r.de)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),o=Object(r.de)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(o===1/0&&Object(r.de)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(o=n/2),t&&(n*=2,o*=2,1===(e=e.map((t,n)=>n>=e.length-2?r.Hf.nearestLargerEven(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=r.Hf.squeezeShape(e);e=t.newShape}let i=r.Hf.sizeFromShape(e),u=null;e.length<=1&&i<=n?u=[1,i]:2===e.length&&e[0]<=n&&e[1]<=n?u=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?u=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?u=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?u=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(u=[e[0],e[1]*e[2]*e[3]]);const a=null!=u&&Math.max(...u)>o&&Math.min(...u)<=(t?2:1)&&Math.min(...u)>0;if(null==u||a)if(t){const t=P(e);let n=2,o=2;e.length&&([n,o]=B(e)),i=t*(n/2)*(o/2),u=r.Hf.sizeToSquarishShape(i).map(e=>2*e)}else u=r.Hf.sizeToSquarishShape(i);return u}function M(e){return e%2==0}function D(e,t){if(e=e.slice(-2),t=t.slice(-2),r.Hf.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(M(n)&&M(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&M(e[0])&&M(t[0])}let w,y;function v(e){if(null==w){const t=Object(o.a)(e);w=t.getParameter(t.MAX_TEXTURE_SIZE)}return w}function X(e){if(null==y){const t=Object(o.a)(e);y=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,y)}function k(e){if(0===e)return 0;let t;const n=Object(o.a)(e);return t=$(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:$(n,"EXT_disjoint_timer_query")?1:0,t}function $(e,t){return null!=e.getExtension(t)}function G(e){try{if(null!=Object(o.a)(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function j(e){if(0===e)return!1;const t=Object(o.a)(e);if(1===e){if(!$(t,"OES_texture_float"))return!1}else if(!$(t,"EXT_color_buffer_float"))return!1;return H(t)}function W(e){if(0===e)return!1;const t=Object(o.a)(e);if(1!==e){if($(t,"EXT_color_buffer_float"))return H(t);const e="EXT_color_buffer_half_float";if($(t,e)){const n=t.getExtension(e);return function(e,t){const n=Object(i.g)(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const u=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),u}(t,n)}return!1}if(!$(t,"OES_texture_float"))return!1;if(!$(t,"WEBGL_color_buffer_float"))return!1;return H(t)}function H(e){const t=Object(i.g)(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),o}function Y(e){if(2!==e)return!1;return null!=Object(o.a)(e).fenceSync}function z(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&r.Hf.assert("complex64"!==e.dtype,()=>t+" does not support complex64 tensors in the WebGL backend.")})}},33:function(e,t,n){"use strict";n.d(t,"a",(function(){return r})),n.d(t,"c",(function(){return o})),n.d(t,"b",(function(){return i})),n.d(t,"i",(function(){return a})),n.d(t,"h",(function(){return s})),n.d(t,"d",(function(){return c})),n.d(t,"e",(function(){return l})),n.d(t,"f",(function(){return f})),n.d(t,"g",(function(){return d}));var r,o,i,u=n(0);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(e,t){return[t,e]}function s(e,t){return e*t}function c(e){const t=u.Hf.sizeFromShape(e),n=Math.ceil(t/4);return u.Hf.sizeToSquarishShape(n)}function l(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function f(e,t){const[n,r]=l(e,t);return n*r*4}function d(e,t){const n=e;let r,o,i,a,s,c,l,f,d,h;return 2===Object(u.de)().getNumber("WEBGL_VERSION")?(r=n.R32F,o=n.R16F,i=n.RGBA16F,a=n.RGBA32F,s=n.RED,l=4,f=1,d=n.HALF_FLOAT,h=n.FLOAT,c=n.RGBA8):(r=e.RGBA,o=e.RGBA,i=e.RGBA,a=n.RGBA,s=e.RGBA,l=4,f=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,c=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:s,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:f,textureTypeHalfFloat:d,textureTypeFloat:h}}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(r||(r={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(o||(o={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(i||(i={}))},357:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(0);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o(){Object(r.de)().set("WEBGL_FORCE_F16_TEXTURES",!0)}},38:function(e,t,n){"use strict";n.d(t,"i",(function(){return UnaryOpProgram})),n.d(t,"b",(function(){return o})),n.d(t,"e",(function(){return i})),n.d(t,"a",(function(){return u})),n.d(t,"d",(function(){return a})),n.d(t,"f",(function(){return s})),n.d(t,"g",(function(){return c})),n.d(t,"c",(function(){return l})),n.d(t,"h",(function(){return f}));var r=n(51);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UnaryOpProgram{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Object(r.e)(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const o="if (isnan(x)) return x;",i="return x;",u="return abs(x);";const a="return (x >= 0.0) ? x : (exp(x) - 1.0);",s=o+"\n  return (x < 0.0) ? 0.0 : x;\n",c=o+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",l="return x;",f="return 1.0 / (1.0 + exp(-1.0 * x));"},460:function(e,t,n){"use strict";n.d(t,"b",(function(){return SwapProgram})),n.d(t,"a",(function(){return MergeProgram}));class SwapProgram{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class MergeProgram{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}},555:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));
/** @license See the LICENSE file. */
const r="4.1.0"},84:function(e,t,n){"use strict";n.d(t,"b",(function(){return o})),n.d(t,"a",(function(){return i})),n.d(t,"c",(function(){return u})),n.d(t,"d",(function(){return a})),n.d(t,"e",(function(){return s})),n.d(t,"f",(function(){return UnaryOpPackedProgram}));var r=n(51);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o="return x;",i="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",u="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",a="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",s="return 1.0 / (1.0 + exp(-1.0 * x));";class UnaryOpPackedProgram{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Object(r.e)(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}},885:function(e,t,n){"use strict";n.d(t,"a",(function(){return TextureManager}));var r=n(0),o=n(67),i=n(33);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class TextureManager{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=a(t,n),o=s(e,r,n);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const c=u(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=c,this.log();const e=this.freeTextures[o].shift();return this.usedTextures[o].push(e),e}let l;return r===i.b.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===i.b.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===i.b.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===i.b.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===i.b.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(l),this.numUsedTextures++,this._numBytesAllocated+=c,this.log(),l}releaseTexture(e,t,n,o){if(null==this.freeTextures)return;const i=a(n,o),c=s(t,i,o);c in this.freeTextures||(this.freeTextures[c]=[]);const l=u(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,o),f=Object(r.de)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==f&&this._numBytesAllocated>f?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=l):(this.freeTextures[c].push(e),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const d=this.usedTextures[c],h=d.indexOf(e);if(h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");d.splice(h,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function u(e,t,n,r,u){const a=function(e,t){switch(e){case i.b.PACKED_2X2_FLOAT32:return Object(o.r)(t);case i.b.PACKED_2X2_FLOAT16:return Object(o.p)(t);case i.b.UNPACKED_FLOAT32:return Object(o.q)(t);case i.b.UNPACKED_FLOAT16:return Object(o.o)(t);case i.b.PACKED_4X1_UNSIGNED_BYTE:return Object(o.s)(t);default:throw new Error("Unknown physical texture type "+e)}}(t,r);let s;if(u){const[t,n]=Object(i.e)(e[0],e[1]);s=t*n}else{const[t,n]=Object(i.i)(e[0],e[1]);s=t*n}return s*function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format "+t)}(n,a)}function a(e,t){if(e===i.c.UPLOAD)return i.b.PACKED_2X2_FLOAT32;if(e===i.c.RENDER||null==e)return function(e){return Object(r.de)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?i.b.PACKED_2X2_FLOAT32:i.b.UNPACKED_FLOAT32:e?i.b.PACKED_2X2_FLOAT16:i.b.UNPACKED_FLOAT16}(t);if(e===i.c.DOWNLOAD||e===i.c.PIXELS)return i.b.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+e)}function s(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}},888:function(e,t,n){"use strict";n.d(t,"a",(function(){return UnpackProgram}));var r=n(51),o=n(60),i=n(40);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class UnpackProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Object(r.e)(this.outputShape.length);const t=e.length,n=Object(o.a)("rc",t),u=Object(i.a)(t),a=Object(o.b)(t,n),s=n.slice(-2),c=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${u} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${c}));\n      }\n    `}}},895:function(e,t,n){"use strict";n.d(t,"a",(function(){return TransposePackedProgram}));var r=n(60),o=n(40);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class TransposePackedProgram{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Object(o.a)(this.rank),u=Object(r.c)("rc",this.rank),a=new Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=u[e];const s=`vec2(${a.slice(-2).join()})`,c=`++${u[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${s})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${c}) {\n        result[1] = ${l};\n      }\n      --${u[this.rank-1]};\n      if(++${u[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${c}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}},896:function(e,t,n){"use strict";n.d(t,"a",(function(){return TransposeProgram}));var r=n(40);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TransposeProgram{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const o=Object(r.a)(this.rank),i=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${o} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}}}]);