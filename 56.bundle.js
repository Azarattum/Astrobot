(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{140:function(t,e,s){"use strict";
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var n,i;s.d(e,"a",(function(){return n})),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"}(n||(n={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(i||(i={}))},278:function(t,e,s){"use strict";s(0),s(112),s(454),s(756)},454:function(t,e,s){"use strict";s.d(e,"a",(function(){return GraphExecutor}));var n=s(0),i=s(1),o=s(455),r=s(456),a=s(272);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class GraphExecutor{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(e=>{this._functionExecutorMap[e]=new GraphExecutor(t.functions[e],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(e=>t[e].map(t=>t.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){const s=t.map(t=>t.name).sort(),n=e.map(t=>t.name).sort();return s.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(t,e){const s=Object(a.a)(t,e,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:i,syncInputs:o}=s;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(n.length>0){const s=e.map(t=>t.name),i=Object.keys(t);throw new Error(`Cannot compute the outputs [${s}] from the provided inputs [${i}]. Missing the following inputs: [${n}]`)}return Object(a.b)(this.graph,this.weightMap,s)}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return Object(n.qe)(e),e}cloneTensorList(t){if(!t)return null;return t.map(t=>this.cloneAndKeepTensor(t))}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([t,e])=>[t,this.cloneTensorList(e)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const a=s.map(t=>this.graph.nodes[Object(i.g)(t)[0]]),c=e.map(t=>Object(i.g)(t)[0]);let h=c.map(t=>this.graph.nodes[t]);0===h.length&&(h=this._outputs);const p=this.getCompilationKey(a,h);let u=this.compiledMap.get(p);null==u&&(u=this.compile(t,h),this.compiledMap.set(p,u));try{this.keepIntermediateTensors=Object(n.de)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(t){this.keepIntermediateTensors=!1,console.warn(t.message)}const d={},T={};return Object(n.Af)(()=>{const s=new r.a(this.weightMap,d,T,this.functionExecutorMap),a=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(e=>{const[s,n]=Object(i.g)(e),o=[];o[n]=t[e],a[s]=o,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(o))});const h=this.getFrozenTensorIds(a),p={};for(let t=0;t<u.length;t++){const e=u[t];if(!a[e.name]){const t=Object(o.a)(e,a,s,this._resourceManager);if(n.Hf.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);a[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposal(e.name,e,a,s,h,c,p)}}return null==this.parent&&s.dispose(h),e.map(t=>Object(i.e)(t,a,s))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(e=>t[e]).map(t=>t.map(t=>t.id)));return new Set(e)}checkTensorForDisposal(t,e,s,n,o,r,a){"control"!==e.category&&-1===r.indexOf(t)&&(s[t].forEach(t=>{null!=t&&(a[t.id]=(a[t.id]||0)+e.children.length)}),e.inputs.forEach(t=>{if("control"!==t.category){const e=Object(i.f)(t.name,s,n);null!=e&&e.forEach(t=>{if(t&&!t.kept&&!o.has(t.id)){const e=a[t.id];1===e?(t.dispose(),delete a[t.id]):null!=e&&a[t.id]--}})}}))}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,e,s=!1,o={},a={}){this.disposeIntermediateTensors(),s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=Object(n.de)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(t){this.keepIntermediateTensors=!1,console.warn(t.message)}const c=new r.a(this.weightMap,o,a,this.functionExecutorMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const h=await this.executeWithControlFlow(t,c,e,s),p=e.map(t=>Object(i.e)(t,h,c)),u=p.map(t=>t.id),d=Object.keys(t).map(e=>t[e].id),T=new Set([...u,...d,...this.weightIds]);return Object.values(h).forEach(t=>{t.forEach(t=>{!t||t.isDisposed||T.has(t.id)||t.dispose()})}),null==this.parent&&c.dispose(T),p}async executeFunctionAsync(t,e,s){const n=t.reduce((t,e,s)=>(t[this.inputs[s].name]=e,t),{});return this._executeAsync(n,this.outputNodes,!0,e,s)}async executeWithControlFlow(t,e,s,n){const o=Object.keys(t),r=o.map(t=>this.graph.nodes[Object(i.g)(t)[0]]),c=s.map(t=>Object(i.g)(t)[0]);let h=c.map(t=>this.graph.nodes[t]);0===h.length&&(h=this._outputs);const{usedNodes:p,missingInputs:u,dynamicNode:d,syncInputs:T}=Object(a.a)(t,h,this.weightMap,this._initNodes),l=[...r,...this.graph.weights,...this._initNodes||[]].map(t=>({node:t,contexts:e.currentContext})),_=Object.assign({},this.weightMap);Object.keys(t).forEach(e=>{const[s,n]=Object(i.g)(e),o=[];o[n]=t[e],_[s]=o});const m={},I=this.getFrozenTensorIds(_),E={};for(;l.length>0;){const t=this.processStack(r,l,e,_,E,I,c,m,p);await Promise.all(t)}null!=d||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const g=h.filter(t=>!Object(a.c)(t)&&!Object(i.e)(t.name,_,e)).map(t=>t.name);if(g.length>0){let t="";throw null!=d&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${T}]`),new Error(`Cannot compute the outputs [${g}] from the provided inputs [${o}]. Consider providing the following inputs: [${u}]. ${t}`)}return _}processStack(t,e,s,r,a,c,h,p,u){const d=[];for(;e.length>0;){const t=e.pop();s.currentContext=t.contexts;let T="";if("Enter"===t.node.op&&Object(i.d)("isConstant",t.node,r,s)&&([T]=Object(i.b)(t.node.name,s)),null==r[t.node.name]){const l=Object(o.a)(t.node,r,s,this._resourceManager);T||([T]=Object(i.b)(t.node.name,s));const _=s.currentContext;n.Hf.isPromise(l)?d.push(l.then(n=>(r[T]=n,this.keepIntermediateTensors&&(this.clonedTensorsMap[T]=this.cloneTensorList(n)),s.currentContext=_,this.checkTensorForDisposal(T,t.node,r,s,c,h,p),this.processChildNodes(t.node,e,s,r,a,u),n))):(r[T]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[T]=this.cloneTensorList(l)),this.checkTensorForDisposal(T,t.node,r,s,c,h,p),this.processChildNodes(t.node,e,s,r,a,u))}else this.processChildNodes(t.node,e,s,r,a,u)}return d}processChildNodes(t,e,s,n,o,r){t.children.forEach(t=>{const[a]=Object(i.b)(t.name,s);!o[a]&&r.has(t.name)&&("Merge"===t.op?t.inputNames.some(t=>!!Object(i.e)(t,n,s))&&(o[a]=!0,e.push({contexts:s.currentContext,node:t})):t.inputNames.every(t=>!!Object(i.e)(t,n,s))&&(o[a]=!0,e.push({contexts:s.currentContext,node:t})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(t=>t.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const s=t[e],[o]=Object(i.g)(e),r=this.graph.nodes[o];if(r.attrParams.shape&&r.attrParams.shape.value){const t=r.attrParams.shape.value,e=t.length===s.shape.length&&s.shape.every((e,s)=>-1===t[s]||t[s]===e);n.Hf.assert(e,()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${t}], but was [${s.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&n.Hf.assert(s.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var e,s;const n={};for(const i in t){const o=null===(s=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===s?void 0:s[i];null!=o?n[o.name]=t[i]:n[i]=t[i]}return n}checkInputs(t){const e=Object.keys(t).filter(t=>{const[e]=Object(i.g)(t);return null==this.graph.nodes[e]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(t=>{var e,s;const n=null===(s=null===(e=this._signature)||void 0===e?void 0:e.outputs)||void 0===s?void 0:s[t];return null!=n?n.name:t},{})}checkOutputs(t){t.forEach(t=>{const[e]=Object(i.g)(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)})}}},456:function(t,e,s){"use strict";s.d(e,"a",(function(){return ExecutionContext}));class ExecutionContext{constructor(t={},e={},s={},n={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=s,this.functionMap=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const s=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}},744:function(t,e,s){"use strict";s.d(e,"a",(function(){return HashTable}));var n=s(0),i=s(27);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class HashTable{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Object(n.af)(0),this.tensorMap=new Map,Object(n.qe)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return i.a(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),Object(n.Af)(()=>{const t=Object(n.Ff)(e),i=s.length,o=t.length;n.Hf.assert(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let e=0;e<i;e++){const i=s[e],o=t[e];Object(n.qe)(o),this.tensorMap.set(i,o)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return Object(n.Af)(()=>{const t=[];for(let n=0;n<s.length;n++){const i=s[n],o=this.findWithDefault(i,e);t.push(o)}return Object(n.rf)(t)})}findWithDefault(t,e){const s=this.tensorMap.get(t);return null!=s?s:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got `+t.dtype);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got `+e.dtype)}}}}]);