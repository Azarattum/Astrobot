(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{108:function(t,n,e){"use strict";e.d(n,"a",(function(){return BaseCallback})),e.d(n,"d",(function(){return o})),e.d(n,"b",(function(){return CallbackConstructorRegistry})),e.d(n,"c",(function(){return u}));var s,a=e(0),r=e(8),i=e(110),c=e(12);!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(s||(s={}));class BaseCallback{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class CallbackList{constructor(t,n=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks)n.setParams(t)}setModel(t){for(const n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){null==n&&(n={});for(const e of this.callbacks)await e.onEpochBegin(t,n)}async onEpochEnd(t,n){null==n&&(n={});for(const e of this.callbacks)await e.onEpochEnd(t,n)}async onBatchBegin(t,n){null==n&&(n={});for(const e of this.callbacks)await e.onBatchBegin(t,n)}async onBatchEnd(t,n){null==n&&(n={});for(const e of this.callbacks)await e.onBatchEnd(t,n)}async onTrainBegin(t){null==t&&(t={});for(const n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const n of this.callbacks)await n.onTrainEnd(t)}}class BaseLogger extends BaseCallback{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){null==n&&(n={});const e=null==n.size?0:n.size;this.seen+=e;for(const t in n){const s=n[t];if("number"==typeof s)this.totals.hasOwnProperty(t)||(this.totals[t]=0),this.totals[t]=this.totals[t]+s*e;else{let n;t in this.totals?n=this.totals[t]:this.totals[t]=0;const r=Object(a.Af)(()=>Object(a.td)(this.totals[t],Object(a.Ie)(s,e)));this.totals[t]=r,null!=n&&n.dispose()}}}async onEpochEnd(t,n){if(null!=n)for(const t of this.params.metrics)null!=this.totals[t]&&("number"==typeof this.totals[t]?n[t]=this.totals[t]/this.seen:Object(a.Af)(()=>{const e=Object(a.Ie)(Object(a.Zd)(1,this.seen),this.totals[t]);n[t]=e,this.totals[t].dispose(),Object(a.qe)(n[t])}))}}class History extends BaseCallback{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){null==n&&(n={}),this.epoch.push(t);for(const t in n)null==this.history[t]&&(this.history[t]=[]),this.history[t].push(n[t])}async syncData(){const t=[],n=[],e=[];for(const s in this.history){const a=this.history[s];for(let r=0;r<a.length;++r)if("number"!=typeof a[r]){const i=a[r];t.push(i.data()),n.push(s),e.push(r)}}const s=await Promise.all(t);for(let t=0;t<s.length;++t){this.history[n[t]][e[t]].dispose(),this.history[n[t]][e[t]]=s[t][0]}}}class CustomCallback extends BaseCallback{constructor(t,n){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||a.Ke,this.yieldEvery=n||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");a.Hf.isNumber(this.yieldEvery)&&(this.maybeWait=c.f(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,e){const s=[];null!=this.yield&&(await Object(i.b)(e),s.push(this.yield(t,n,e))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(t,n){this.currentEpoch=t,null!=this.epochBegin&&(await Object(i.b)(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){const e=[];null!=this.epochEnd&&(await Object(i.b)(n),e.push(this.epochEnd(t,n))),"epoch"===this.yieldEvery&&e.push(this.nextFrameFunc()),await Promise.all(e)}async onBatchBegin(t,n){null!=this.batchBegin&&(await Object(i.b)(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){const e=[];null!=this.batchEnd&&(await Object(i.b)(n),e.push(this.batchEnd(t,n))),"batch"===this.yieldEvery?e.push(this.nextFrameFunc()):a.Hf.isNumber(this.yieldEvery)&&e.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(e)}async onTrainBegin(t){null!=this.trainBegin&&(await Object(i.b)(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await Object(i.b)(t),await this.trainEnd(t))}}function o(t,n){if(null==t&&(t={}),t instanceof BaseCallback)return[t];if(Array.isArray(t)&&t[0]instanceof BaseCallback)return t;return c.o(t).map(t=>new CustomCallback(t,n))}class CallbackConstructorRegistry{constructor(){}static registerCallbackConstructor(t,n){a.Hf.assert(t>=0&&Number.isInteger(t),()=>"Verbosity level is expected to be an integer >= 0, but got "+t),CallbackConstructorRegistry.checkForDuplicate(n),null==CallbackConstructorRegistry.constructors[t]&&(CallbackConstructorRegistry.constructors[t]=[]),CallbackConstructorRegistry.constructors[t].push(n)}static checkForDuplicate(t){for(const n in CallbackConstructorRegistry.constructors){CallbackConstructorRegistry.constructors[+n].forEach(n=>{if(n===t)throw new r.e("Duplicate callback constructor.")})}}static clear(){CallbackConstructorRegistry.constructors={}}static createCallbacks(t){const n=[];for(const e in CallbackConstructorRegistry.constructors){const s=+e;t>=s&&n.push(...CallbackConstructorRegistry.constructors[s])}return n.map(t=>new t)}}function u(t,n,e,s,a,r,i,c,o){const u=new History,l=[new BaseLogger,...CallbackConstructorRegistry.createCallbacks(n)];null!=t&&l.push(...t),l.push(u);const h=new CallbackList(l);return h.setParams({epochs:e,initialEpoch:s,samples:a,steps:r,batchSize:i,verbose:n,doValidation:c,metrics:o}),{callbackList:h,history:u}}CallbackConstructorRegistry.constructors={}},136:function(t,n,e){"use strict";e.d(n,"a",(function(){return a})),e.d(n,"b",(function(){return i}));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let s=0;function a(){return s++}const r={};function i(t=""){return t in r||(r[t]=0),r[t]+=1,t+r[t].toString()}},21:function(t,n,e){"use strict";e.d(n,"c",(function(){return o})),e.d(n,"i",(function(){return u})),e.d(n,"o",(function(){return l})),e.d(n,"j",(function(){return h})),e.d(n,"a",(function(){return f})),e.d(n,"q",(function(){return d})),e.d(n,"p",(function(){return b})),e.d(n,"e",(function(){return g})),e.d(n,"d",(function(){return y})),e.d(n,"t",(function(){return k})),e.d(n,"n",(function(){return w})),e.d(n,"f",(function(){return m})),e.d(n,"k",(function(){return E})),e.d(n,"s",(function(){return C})),e.d(n,"b",(function(){return B})),e.d(n,"h",(function(){return A})),e.d(n,"r",(function(){return x})),e.d(n,"g",(function(){return j})),e.d(n,"l",(function(){return O})),e.d(n,"m",(function(){return S}));var s=e(0),a=e(31),r=e(8),i=e(47),c=e(50);function o(t,n){return s.Id(t,n)}function u(t,n=-1){const e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),s.Ye(t,e)}function l(t,n){return Object(s.Af)(()=>{if(2!==t.shape.length)throw new r.e(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return k(u(t,1),[1,n,1])})}function h(t){const n=[i.a(t.shape)];return s.Ye(t,n)}function f(t){if(t.rank<=1)throw new r.e(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const n=[t.shape[0],i.a(t.shape,1)];return s.Ye(t,n)}function d(t,n,e){return Object(s.Af)(()=>{switch(t.rank){case 1:return s.hf(t,n,e);case 2:return s.if(t,[n,0],[e,t.shape[1]]);case 3:return s.jf(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return s.kf(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return s.gf(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return s.gf(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new r.e("sliceAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}})}function p(t,n,e){return Object(s.Af)(()=>{switch(t.rank){case 1:return s.hf(t,n,e);case 2:return s.if(t,[0,n],[t.shape[0],e]);case 3:return s.jf(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return s.kf(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new r.e("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}})}function b(t,n,e,a){return Object(s.Af)(()=>{switch(t.rank){case 1:return s.hf(t,n,e);case 2:switch(a){case 1:return d(t,n,e);case 2:return p(t,n,e);default:throw new r.e("The axis is not within the rank of the tensor "+a)}case 3:switch(a){case 1:return d(t,n,e);case 2:return s.jf(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return p(t,n,e);default:throw new r.e("The axis is not within the rank of the tensor "+a)}case 4:switch(a){case 1:return d(t,n,e);case 2:return s.kf(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return s.kf(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return p(t,n,e);default:throw new r.e("The axis is not within the rank of the tensor "+a)}default:throw new r.e("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}})}function g(t,n=-1){let e;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),s.Ld(t,n)}function y(t,n){switch(t.rank){case 1:return s.Md([t,n]);case 2:return s.Nd([t,n],0);case 3:return s.Od([t,n],0);case 4:return s.Pd([t,n],0);default:throw new r.e("concatAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}}function k(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new r.e(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return s.Bf(t,n)}function w(t,n=0,e=1,a,r){return s.Se(t,n,e,a,r)}function m(t,n,e,a){if(t.rank<2||n.rank<2)throw new r.c(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3){if(t.shape.slice(-1)[0]!==n.shape.slice(-2)[0])throw new r.c(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = `+n.shape)}if(2===t.rank&&2===n.rank){const r=!1,i=!1;return s.ke.matMul({a:t,b:n,transposeA:r,transposeB:i,bias:a?v(t.rank,a,Object(c.b)()):null,activation:e})}{const r=t.shape.slice(),i=r.pop();t=s.Ye(t,[-1,i]);const o=n.shape.slice(),u=o.pop(),l=o.pop(),h=[...o,u],f=Array.from({length:n.rank},(t,e)=>0===e?n.rank-2:e<=n.rank-2?e-1:e);n=s.Ye(s.Df(n,f),[l,-1]);const d=[...r,...h],p=!1,b=!1;return s.Ye(s.ke.matMul({a:t,b:n,transposeA:p,transposeB:b,bias:a?v(t.rank,a,Object(c.b)()):null,activation:e}),d)}}function E(t,n,e){return Object(s.Af)(()=>(n=Array.isArray(n)?Object(s.xf)(n,"int32"):s.Id(n,"int32"),s.le(t,n,e)))}function C(t){return s.Ie(t,t)}function v(t,n,e){const a=n.shape;if(1!==n.rank&&n.rank!==t)throw new r.e("Unexpected bias dimensions: "+n.rank+"; expected it to be 1 or "+t);if(5===t){if("channelsFirst"===e)return 1===a.length?s.Ye(n,[1,a[0],1,1,1]):s.Ye(n,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===e)return 1===a.length?s.Ye(n,[1,1,1,1,a[0]]):s.Ye(n,[1].concat(a))}else if(4===t){if("channelsFirst"===e)return 1===a.length?s.Ye(n,[1,a[0],1,1]):s.Ye(n,[1,a[2],a[0],a[1]]);if("channelsLast"===e)return 1===a.length?s.Ye(n,[1,1,1,a[0]]):s.Ye(n,[1].concat(a))}else if(3===t){if("channelsFirst"===e)return 1===a.length?s.Ye(n,[1,a[0],1]):s.Ye(n,[1,a[1],a[0]]);if("channelsLast"===e)return 1===a.length?s.Ye(n,[1,1,a[0]]):s.Ye(n,[1].concat(a))}else if(t<3)return n;throw new r.e("Unsupported input rank by biasAdd: "+n.rank)}function B(t,n,e){return Object(s.Af)(()=>(null==e&&(e=Object(c.b)()),Object(a.a)(e),s.td(t,v(t.rank,n,e))))}function A(t,n=1){if(1!==n)throw new r.c(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return s.be(t)}function x(t){return Object(s.Af)(()=>s.Zd(t,s.td(s.sd(t),1)))}function j(t,n,e,a){return Object(s.Af)(()=>s.ae(t,n,e,a))}function O(t){return Object(s.Af)(()=>{const n=s.td(.5,s.Ie(.2,t));return s.Jd(n,0,1)})}function S(t,n,e=!1){return e?t():n()}},277:function(t,n,e){"use strict";var s=e(108);e(149),e(8),e(110);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
s.a},31:function(t,n,e){"use strict";e.d(n,"a",(function(){return i})),e.d(n,"b",(function(){return c})),e.d(n,"c",(function(){return o})),e.d(n,"d",(function(){return u})),e.d(n,"g",(function(){return h})),e.d(n,"e",(function(){return f})),e.d(n,"f",(function(){return d}));var s=e(205),a=e(12);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const r=new Map;function i(t){Object(a.d)(s.b,"DataFormat",t)}function c(t){Object(a.d)(s.c,"InterpolationFormat",t)}function o(t){Object(a.d)(s.d,"PaddingMode",t)}function u(t){Object(a.d)(s.e,"PoolMode",t)}const l=[];function h(t,n){l.push(t);try{const t=n();return l.pop(),t}catch(t){throw l.pop(),t}}function f(t){if(!b(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===l.length?"":l.join("/")+"/")+t}function d(t){if(!b(t))throw new Error("Not a valid tensor name: '"+t+"'");r.has(t)||r.set(t,0);const n=r.get(t);if(r.set(t,r.get(t)+1),n>0){const e=`${t}_${n}`;return r.set(e,1),e}return t}const p=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function b(t){return!!t.match(p)}},50:function(t,n,e){"use strict";e.d(n,"a",(function(){return r})),e.d(n,"b",(function(){return i}));var s=e(0);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let a;function r(){return null==a&&(a=Object(s.zd)().epsilon()),a}function i(){return"channelsLast"}},74:function(t,n,e){"use strict";e.d(n,"a",(function(){return Softmax})),e.d(n,"c",(function(){return i})),e.d(n,"b",(function(){return o}));var s=e(0),a=e(21),r=e(12);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Activation extends s.df.Serializable{getConfig(){return{}}}class Elu extends Activation{apply(t,n=1){return a.h(t,n)}}Elu.className="elu",s.df.registerClass(Elu);class Selu extends Activation{apply(t){return s.bf(t)}}Selu.className="selu",s.df.registerClass(Selu);class Relu extends Activation{apply(t){return s.Xe(t)}}Relu.className="relu",s.df.registerClass(Relu);class Relu6 extends Activation{apply(t){return Object(s.Af)(()=>s.Ge(6,s.Xe(t)))}}Relu6.className="relu6",s.df.registerClass(Relu6);class Linear extends Activation{apply(t){return t}}Linear.className="linear",s.df.registerClass(Linear);class Sigmoid extends Activation{apply(t){return s.ff(t)}}Sigmoid.className="sigmoid",s.df.registerClass(Sigmoid);class HardSigmoid extends Activation{apply(t){return a.l(t)}}HardSigmoid.className="hardSigmoid",s.df.registerClass(HardSigmoid);class Softplus extends Activation{apply(t){return s.nf(t)}}Softplus.className="softplus",s.df.registerClass(Softplus);class Softsign extends Activation{apply(t){return a.r(t)}}Softsign.className="softsign",s.df.registerClass(Softsign);class Tanh extends Activation{apply(t){return s.vf(t)}}Tanh.className="tanh",s.df.registerClass(Tanh);class Softmax extends Activation{apply(t,n=-1){return s.mf(t,n)}}Softmax.className="softmax",s.df.registerClass(Softmax);class LogSoftmax extends Activation{apply(t,n=-1){return s.we(t,n)}}LogSoftmax.className="logSoftmax",s.df.registerClass(LogSoftmax);class Swish extends Activation{apply(t,n=1){return Object(s.Af)(()=>s.Ie(s.ff(s.Ie(t,n)),t))}}Swish.className="swish",s.df.registerClass(Swish);class Mish extends Activation{apply(t){return Object(s.Af)(()=>s.Ie(t,s.vf(s.nf(t))))}}function i(t){return t.getClassName()}function c(t,n={}){return Object(r.g)(t,s.df.SerializationMap.getMap().classNameMap,n,"activation")}function o(t){if(null==t){const t={className:"linear",config:{}};return c(t)}if("string"==typeof t){const n={};return n.className=t,n.config={},c(n)}return t instanceof Activation?t:c(t)}Mish.className="mish",s.df.registerClass(Mish)}}]);