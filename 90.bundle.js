(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{1060:function(e,n,t){"use strict";t.d(n,"a",(function(){return SelectProgram}));var r=t(40);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SelectProgram{constructor(e,n,t){let o,i;if(this.variableNames=["c","a","b"],this.outputShape=n,t>4)throw Error(`Where for rank ${t} is not yet supported`);if(1===t)i="resRC",o="resRC";else{const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],c=[];for(let o=0;o<n.length;o++)c.push(""+t[o]),o<e&&r.push(""+t[o]);o=r.join(),i=c.join()}const c=Object(r.a)(t);this.userCode=`\n      void main() {\n        ${c} resRC = getOutputCoords();\n        float cVal = getC(${o});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}},1079:function(e,n,t){"use strict";t.d(n,"a",(function(){return StridedSliceProgram}));var r=t(40);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class StridedSliceProgram{constructor(e,n,t){this.variableNames=["x"],this.outputShape=t;const o=t.length,i=Object(r.a)(t.length),c=Object(r.a)(t.length);let a="";if(1===o)a="coords * strides + begin";else{let e=0;a=t.map((n,r)=>(e++,1===t.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${e});\n      ${i} strides = ${i}(${n});\n\n      void main() {\n        ${c} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}},40:function(e,n,t){"use strict";t.d(n,"c",(function(){return a})),t.d(n,"a",(function(){return v})),t.d(n,"b",(function(){return S}));var r=t(0),o=t(62),i=t(61);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const{getBroadcastDims:c}=r.Ad;function a(e,n,t){const a=[];if(e.forEach(e=>{const n=r.Hf.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push(`uniform float ${e.name}${n>1?`[${n}]`:""};`):(a.push(`uniform sampler2D ${e.name};`),a.push(`uniform int offset${e.name};`)),t.enableShapeUniforms){const{uniformShape:n}=S(t.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(n.length){case 1:a.push(`uniform int ${e.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${e.name}Shape;`)}a.push(`uniform ivec2 ${e.name}TexShape;`)}}),t.enableShapeUniforms){switch(n.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(e=>{a.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)});const $=a.join("\n"),f=e.map(e=>function(e,n,t=!1,o){let i="";i+=t?s(e,o):u(e,o);const a=e.shapeInfo.logicalShape,l=n.logicalShape;a.length<=l.length&&(i+=t?function(e,n){const t=e.name,o=t.charAt(0).toUpperCase()+t.slice(1),i="get"+o+"AtOutCoords",a=e.shapeInfo.logicalShape.length,u=n.logicalShape.length,s=c(e.shapeInfo.logicalShape,n.logicalShape),l=v(u),p=u-a;let h;const x=["x","y","z","w","u","v"];h=0===a?"":u<2&&s.length>=1?"coords = 0;":s.map(e=>`coords.${x[e+p]} = 0;`).join("\n");let d="";d=u<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,n)=>"coords."+x[n+p]).join(", ");let $="return outputValue;";const f=1===r.Hf.sizeFromShape(e.shapeInfo.logicalShape),S=1===r.Hf.sizeFromShape(n.logicalShape);if(1!==a||f||S){if(f&&!S)$=1===u?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(s.length){const e=a-2,n=a-1;s.indexOf(e)>-1&&s.indexOf(n)>-1?$="return vec4(outputValue.x);":s.indexOf(e)>-1?$="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":s.indexOf(n)>-1&&($="return vec4(outputValue.xx, outputValue.zz);")}}else $="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      vec4 outputValue = get${o}(${d});\n      ${$}\n    }\n  `}(e,n):function(e,n){const t=e.name,o=t.charAt(0).toUpperCase()+t.slice(1),i="get"+o+"AtOutCoords",a=n.texShape,u=e.shapeInfo.texShape,s=e.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!e.shapeInfo.isUniform&&s===l&&null==e.shapeInfo.flatOffset&&r.Hf.arraysEqual(u,a))return`\n      float ${i}() {\n        return sampleTexture(${t}, resultUV);\n      }\n    `;const p=v(l),h=c(e.shapeInfo.logicalShape,n.logicalShape),x=l-s;let d;const $=["x","y","z","w","u","v"];d=0===s?"":l<2&&h.length>=1?"coords = 0;":h.map(e=>`coords.${$[e+x]} = 0;`).join("\n");let f="";f=l<2&&s>0?"coords":e.shapeInfo.logicalShape.map((e,n)=>"coords."+$[n+x]).join(", ");return`\n    float ${i}() {\n      ${p} coords = getOutputCoords();\n      ${d}\n      return get${o}(${f});\n    }\n  `}(e,n));return i}(e,n,t.packedInputs,t.enableShapeUniforms)).join("\n"),m=n.texShape,C=Object(o.a)(),T=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(C);let g,R,w=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${l}\n    ${p}\n    ${h}\n  `}(C);n.isPacked?(g=function(e,n,t){switch(e.length){case 0:return d();case 1:return function(e,n,t){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(1===r[0])return t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(t)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,n,t);case 2:return function(e,n,t){const o=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(r.Hf.arraysEqual(e,n))return t?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${o[0]}, ${o[1]}));\n      }\n    `;const i=Math.ceil(e[1]/2);if(t)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${o[0]}, ${o[1]}));\n\n      int index = resTexRC.x * ${o[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function(e,n,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(e[2]/2),i=o*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,n,t);default:return function(e,n,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(e[e.length-1]/2),i=o*Math.ceil(e[e.length-2]/2);let c=i,a="",u="b, r, c";for(let n=2;n<e.length-1;n++)c*=e[e.length-n-1],a=`\n      int b${n} = index / ${c};\n      index -= b${n} * ${c};\n    `+a,u=`b${n}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}(e,n,t)}}(n.logicalShape,m,t.enableShapeUniforms),R=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(C)):(g=function(e,n,t){switch(e.length){case 0:return d();case 1:return function(e,n,t){if(1===n[0])return t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `;if(1===n[1])return t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `;if(t)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,t);case 2:return function(e,n,t){if(r.Hf.arraysEqual(e,n))return t?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;if(1===e[1])return t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(t)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function(e,n,t){if(t){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${i.f(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=i.d(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,n,t);case 4:return function(e,n,t){if(t){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${i.f(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=i.d(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,n,t);case 5:return function(e,n){const t=i.d(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,n);case 6:return function(e,n){const t=i.d(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,n);default:throw new Error(e.length+"-D output sampling is not yet supported")}}(n.logicalShape,m,t.enableShapeUniforms),R=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(C)),t.packedInputs&&(w+=x);return[w,T,R,$,g,f,t.userCode].join("\n")}function u(e,n=!1){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[o,i]=e.shapeInfo.texShape;if(1===o&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const c=$(t);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${c});\n      return sampleTexture(${t}, uv);\n    }\n  `;const[a,u]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${u}, ${c});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 1:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${f(e)}\n      }\n    `;const o=e.shapeInfo.texShape,i=o[0],c=o[1];if(1===c&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=$(t);if(1===c)return n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(1===i)return n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${c}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(n)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${c}, index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const t=e.shapeInfo.logicalShape,o=e.name,i="get"+o.charAt(0).toUpperCase()+o.slice(1),c=e.shapeInfo.texShape;if(null!=c&&r.Hf.arraysEqual(t,c)){if(n)return`\n      float ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `;const e=c[0],t=c[1];return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${t}.0, ${e}.0);\n      return sampleTexture(${o}, uv);\n    }\n  `}const{newShape:a,keptDims:s}=r.Hf.squeezeShape(t),l=a;if(l.length<t.length){const t=m(e,l),r=["row","col"];return`\n      ${u(t,n)}\n      float ${i}(int row, int col) {\n        return ${i}(${C(r,s)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${f(e)}\n      }\n    `;const p=c[0],h=c[1],x=$(o);if(1===h)return n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${x}), vec3(${o}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${o}TexShape[0]));\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${x}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);\n      return sampleTexture(${o}, uv);\n    }\n  `;if(1===p)return n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${x}), vec3(${o}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${o}TexShape[1]), 0.5);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${x}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);\n      return sampleTexture(${o}, uv);\n    }\n  `;if(n)return`\n      float ${i}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o}Shape[1] + col + ${x};\n        vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);\n        return sampleTexture(${o}, uv);\n      }\n    `;return`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${x};\n    vec2 uv = uvFromFlat(${p}, ${h}, index);\n    return sampleTexture(${o}, uv);\n  }\n`}(e,n);case 3:return function(e,n){const t=e.shapeInfo.logicalShape,o=e.name,i="get"+o.charAt(0).toUpperCase()+o.slice(1),c=t[1]*t[2],a=t[2],{newShape:s,keptDims:l}=r.Hf.squeezeShape(t),p=s;if(p.length<t.length){const t=m(e,p),r=["row","col","depth"];return`\n        ${u(t,n)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${C(r,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${c}, ${a}, 1)));\n        ${f(e)}\n      }\n    `;const h=e.shapeInfo.texShape,x=h[0],d=h[1],v=e.shapeInfo.flatOffset;if(d===c&&null==v)return n?`\n      float ${i}(int row, int col, int depth) {\n        int stride1 = ${o}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${x}.0);\n          return sampleTexture(${o}, uv);\n        }\n      `;if(d===a&&null==v)return n?`\n      float ${i}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${o}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${x}.0);\n      return sampleTexture(${o}, uv);\n    }\n  `;const S=$(o);if(n)return`\n    float ${i}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${o}Shape[1] * ${o}Shape[2];\n      int stride1 = ${o}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${S};\n      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);\n      return sampleTexture(${o}, uv);\n    }\n    `;return`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${c} + col * ${a} + depth + ${S};\n        vec2 uv = uvFromFlat(${x}, ${d}, index);\n        return sampleTexture(${o}, uv);\n      }\n  `}(e,n);case 4:return function(e,n){const t=e.shapeInfo.logicalShape,o=e.name,i="get"+o.charAt(0).toUpperCase()+o.slice(1),c=t[3],a=t[2]*c,s=t[1]*a,{newShape:l,keptDims:p}=r.Hf.squeezeShape(t);if(l.length<t.length){const t=m(e,l),r=["row","col","depth","depth2"];return`\n      ${u(t,n)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${C(r,p)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${s}, ${a}, ${c}, 1)));\n        ${f(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,x=e.shapeInfo.texShape,d=x[0],v=x[1],S=`int stride2 = ${o}Shape[3];`,T=`int stride1 = ${o}Shape[2] * stride2;`,g=`int stride0 = ${o}Shape[1] * stride1;`;if(v===s&&null==h)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        ${S}\n        ${T}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${c}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${d}.0);\n        return sampleTexture(${o}, uv);\n      }\n    `;if(v===c&&null==h)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${o}Shape[1] * ${o}Shape[2], ${o}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${o}TexShape[1], ${o}TexShape[0]);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${d}.0);\n        return sampleTexture(${o}, uv);\n      }\n    `;const R=$(o);if(n)return`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${S}\n      ${T}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index + ${R});\n      return sampleTexture(${o}, uv);\n    }\n  `;return`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${s} + col * ${a} +\n          depth * ${c} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${v}, index + ${R});\n      return sampleTexture(${o}, uv);\n    }\n  `}(e,n);case 5:return function(e){const n=e.shapeInfo.logicalShape,t=e.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n[4],c=n[3]*i,a=n[2]*c,s=n[1]*a,{newShape:l,keptDims:p}=r.Hf.squeezeShape(n);if(l.length<n.length){const n=m(e,l),t=["row","col","depth","depth2","depth3"];return`\n      ${u(n)}\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        return ${o}(${C(t,p)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${s}, ${a}, ${c}, ${i})) +\n          depth3;\n        ${f(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,x=e.shapeInfo.texShape,d=x[0],v=x[1];if(v===s&&null==h)return`\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${c}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${d}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(v===i&&null==h)return`\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${d}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;const S=$(t);return`\n    float ${o}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${s} + col * ${a} + depth * ${c} +\n          depth2 * ${i} + depth3 + ${S};\n      vec2 uv = uvFromFlat(${d}, ${v}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 6:return function(e){const n=e.shapeInfo.logicalShape,t=e.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:c}=r.Hf.squeezeShape(n);if(i.length<n.length){const n=m(e,i),t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${u(n)}\n      float ${o}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${o}(${C(t,c)});\n      }\n    `}const a=n[5],s=n[4]*a,l=n[3]*s,p=n[2]*l,h=n[1]*p;if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${h}, ${p}, ${l}, ${s})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${f(e)}\n      }\n    `;const x=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,v=d[0],S=d[1];if(S===h&&null==x)return`\n      float ${o}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${p}, ${l}, ${s}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${S}.0, ${v}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(S===a&&null==x)return`\n      float ${o}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${S}.0, ${v}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;const T=$(t);return`\n    float ${o}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${h} + col * ${p} + depth * ${l} +\n          depth2 * ${s} + depth3 * ${a} + depth4 + ${T};\n      vec2 uv = uvFromFlat(${v}, ${S}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);default:throw new Error(t.length+"-D input sampling is not yet supported")}}function s(e,n){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1),r=Object(o.a)();return`\n    vec4 ${t}() {\n      return ${r.texture2D}(${n}, halfCR);\n    }\n  `}(e);case 1:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e.shapeInfo.texShape,c=Object(o.a)();if(n)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${c.texture2D}(${t}, uv);\n    }\n  `;const a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${a[0]}, ${a[1]}, index);\n      return ${c.texture2D}(${t}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const t=e.shapeInfo.logicalShape,i=e.name,c="get"+i.charAt(0).toUpperCase()+i.slice(1),a=e.shapeInfo.texShape,u=a[0],s=a[1],l=Object(o.a)();if(null!=a&&r.Hf.arraysEqual(t,a))return n?`\n      vec4 ${c}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n\n        return ${l.texture2D}(${i}, uv);\n      }\n    `:`\n      vec4 ${c}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}.0, ${u}.0);\n\n        return ${l.texture2D}(${i}, uv);\n      }\n    `;if(n)return`\n    vec4 ${c}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${i}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `;const p=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],h=Math.ceil(t[1]/2);return`\n    vec4 ${c}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${h}, ${p[0]}, ${p[1]}, row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `}(e,n);case 3:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),c=e.shapeInfo.texShape,a=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];if(1===t[0]){const r=t.slice(1),o=[1,2],c=m(e,r),a=["b","row","col"];return`\n        ${s(c,n)}\n        vec4 ${i}(int b, int row, int col) {\n          return ${i}(${C(a,o)});\n        }\n      `}const u=Object(o.a)();if(n)return`\n    vec4 ${i}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const l=a[0],p=a[1],h=Math.ceil(t[2]/2),x=h*Math.ceil(t[1]/2);return`\n    vec4 ${i}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${p}, ${x}, ${h}, b, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(e,n);default:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=Object(o.a)();if(n)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${t}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);\n    }\n  `;const c=e.shapeInfo.logicalShape,a=c.length,u=e.shapeInfo.texShape,s=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],l=s[0],p=s[1],h=Math.ceil(c[a-1]/2);let x=h*Math.ceil(c[a-2]/2),d="int b, int row, int col",$=`b * ${x} + (row / 2) * ${h} + (col / 2)`;for(let e=2;e<a-1;e++)d=`int b${e}, `+d,x*=c[a-e-1],$=`b${e} * ${x} + `+$;return`\n    vec4 ${r}(${d}) {\n      int index = ${$};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});\n      return ${i.texture2D}(${t}, uv);\n    }\n  `}(e,n)}}const l="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",p="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",h="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",x="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function d(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function $(e){return"offset"+e}function f(e){const n=e.name,t=r.Hf.sizeFromShape(e.shapeInfo.logicalShape);return t<2?`return ${n};`:`\n    for (int i = 0; i < ${t}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function v(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function S(e,n,t){const{newShape:o,keptDims:i}=r.Hf.squeezeShape(n),c=n.length,a=e&&3===c&&1===n[0],u=a?n.slice(1):o,s=!e&&c>1&&!r.Hf.arraysEqual(n,t)&&o.length<c||a;return{useSqueezeShape:s,uniformShape:s?u:n,keptDims:i}}function m(e,n){const t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function C(e,n){return n.map(n=>e[n]).join(", ")}},61:function(e,n,t){"use strict";t.d(n,"d",(function(){return o})),t.d(n,"f",(function(){return i})),t.d(n,"e",(function(){return c})),t.d(n,"b",(function(){return a})),t.d(n,"c",(function(){return u})),t.d(n,"a",(function(){return s}));var r=t(0);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o(e,n,t="index"){const o=r.Hf.computeStrides(n);return o.map((n,r)=>`${`int ${e[r]} = ${t} / ${n}`}; ${r===o.length-1?`int ${e[r+1]} = ${t} - ${e[r]} * ${n}`:`index -= ${e[r]} * ${n}`};`).join("")}function i(e,n,t="index"){const o=r.Hf.computeStrides(n);return o.map((n,r)=>`${`int ${e[r]} = ${t} / outShapeStrides[${r}]`}; ${r===o.length-1?`int ${e[r+1]} = ${t} - ${e[r]} * outShapeStrides[${r}]`:`index -= ${e[r]} * outShapeStrides[${r}]`};`).join("")}function c(e,n,t="index"){const r=function(e,n){const t=e.length,r=e.map(e=>`${n}[${e}]`),o=new Array(t-1);o[t-2]=r[t-1];for(let e=t-3;e>=0;--e)o[e]=`(${o[e+1]} * ${r[e+1]})`;return o}(e.map((e,n)=>n),n);return r.map((n,o)=>`${`int ${e[o]} = ${t} / ${r[o]}`}; ${o===r.length-1?`int ${e[o+1]} = ${t} - ${e[o]} * ${r[o]}`:`index -= ${e[o]} * ${r[o]}`};`).join("")}function a(e){const n=r.Hf.computeStrides(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}function u(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}const s="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n"},926:function(e,n,t){"use strict";t.d(n,"a",(function(){return SlicePackedProgram}));var r=t(60),o=t(40);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class SlicePackedProgram{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Object(o.a)(this.rank),t=Object(r.a)("coords",this.rank),i=Object(r.a)("sourceLoc",this.rank),c=1===this.rank?"sourceLoc":`vec2(${i.slice(-2).join()})`,a=`getChannel(getSource(${i.join()}), ${c})`,u=`\n      result.x = ${a};\n      if (++${t[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${a};\n        --${i[this.rank-1]};\n      }\n    `,s=1===this.rank?"":`\n      --${t[this.rank-1]};\n      if (++${t[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${a};\n        if (++${t[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${n}(${e.map((e,n)=>`start[${n}]`).join()});`:e.map((e,n)=>`${i[n]} = ${t[n]} + start[${n}];`).join("\n");this.userCode=`\n      void main() {\n        ${n} coords = getOutputCoords();\n        ${n} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${u}\n        ${s}\n        setOutput(result);\n      }\n    `}}},927:function(e,n,t){"use strict";t.d(n,"a",(function(){return SliceProgram}));var r=t(40);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SliceProgram{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Object(r.a)(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=function(e){if(1===e)return"sourceLoc";if(e<=6)return o.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let i;i=`\n        ${n} sourceLoc;\n        ${n} coords = getOutputCoords();\n        ${e.map((e,n)=>`sourceLoc.${o[n]} = start[${n}] + coords.${o[n]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${i}\n        setOutput(getSource(${t}));\n      }\n    `}}const o=["x","y","z","w","u","v"]}}]);