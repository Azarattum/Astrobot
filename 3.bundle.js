(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{271:function(e,t,s){"use strict";s.d(t,"a",(function(){return i})),s.d(t,"b",(function(){return a})),s.d(t,"c",(function(){return o})),s.d(t,"d",(function(){return h}));var n=s(0),r=s(78);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class TensorList{constructor(e,t,s,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,null!=e&&e.forEach(e=>{if(s!==e.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${e.dtype}`);Object(r.a)(t,e.shape,"TensorList shape mismatch: "),Object(n.qe)(e)}),this.idTensor=Object(n.af)(0),this.maxNumElements=i,Object(n.qe)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new TensorList([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==s&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Object(r.a)(e,this.elementShape,"TensorList shape mismatch: ");const i=Object(r.b)(this.elementShape,this.tensors,e);return Object(n.Af)(()=>{const e=this.tensors.map(e=>Object(n.Ye)(e,i));return Object(n.rf)(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const s=Object(r.b)(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,Object(r.a)(i.shape,e,"TensorList shape mismatch: "),Object(n.Ye)(i,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Object(r.a)(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Object(n.qe)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+e);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new TensorList([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);Object(r.a)(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=Object(r.b)(this.elementShape,this.tensors,t);return Object(n.Ye)(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Object(r.a)(this.elementShape,t.shape,"TensorList shape mismatch: "),Object(n.qe)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Object(r.a)(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=Object(r.b)(this.elementShape,this.tensors,s);return 0===e.length?Object(n.wf)([],[0].concat(i)):Object(n.Af)(()=>{const t=e.map(e=>Object(n.Ye)(this.tensors[e],i));return Object(n.rf)(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Object(r.a)(this.elementShape,t,"TensorList shape mismatch: ");const s=Object(r.b)(this.elementShape,this.tensors,t);return 0===this.size()?Object(n.wf)([],[0].concat(s)):Object(n.Af)(()=>{const e=this.tensors.map(e=>Object(n.Ye)(e,s));return Object(n.Ld)(e,0)})}}function i(e,t,s){const i=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+e.shape);if(e.dtype!==s)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${s}`);const a=e.shape.slice(1);Object(r.a)(a,t,"TensorList shape mismatch: ");const o=Object(n.Ff)(e);return new TensorList(o,t,i)}function a(e,t,s,n){return new TensorList([],e,t,n)}function o(e,t,s,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const i=Math.max(...t);if(null!=r&&-1!==r&&i>=r)throw new Error(`Max index must be < array size (${i}  vs. ${r})`);const a=new TensorList([],s,e.dtype,r),o=Object(n.Ff)(e,0);return t.forEach((e,t)=>{a.setItem(e,o[t])}),a}function h(e,t,s){let i=0;const a=t.map(e=>(i+=e,i));if(i!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${i}, and tensor's shape is: ${e.shape}`);const o=e.shape.slice(1),h=Object(r.c)(o,s),l=0===i?0:e.size/i,c=Object(n.Af)(()=>{const s=[];e=Object(n.Ye)(e,[1,i,l]);for(let r=0;r<t.length;++r){const i=[0,0===r?0:a[r-1],0],o=[1,t[r],l];s[r]=Object(n.Ye)(Object(n.gf)(e,i,o),h)}return e.dispose(),s}),p=new TensorList([],s,e.dtype,t.length);for(let e=0;e<c.length;e++)p.setItem(e,c[e]);return p}},272:function(e,t,s){"use strict";s.d(t,"a",(function(){return r})),s.d(t,"b",(function(){return i})),s.d(t,"c",(function(){return l}));var n=s(1);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(e,t,s,r){const i=new Set,a=[];let o=null,h=null;const m=new Set,d=Object.keys(e).map(e=>Object(n.g)(e)[0]);let u=[];null!=r&&(u=r.map(e=>Object(n.g)(e.name)[0]));const f=[...t];for(;f.length>0;){const e=f.pop();(l(e)||c(e)||p(e))&&null==o&&(o=e,h=o.children.map(e=>e.name).filter(e=>i.has(e))),i.add(e.name),null==s[e.name]&&(-1===d.indexOf(e.name)&&-1===u.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach(e=>{m.has(e.name)||(m.add(e.name),f.push(e))}):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:i,missingInputs:a,dynamicNode:o,syncInputs:h}}function i(e,t,s){const{usedNodes:r,inputs:i}=s,a=[],o=Object.keys(i).map(e=>Object(n.g)(e)[0]).map(t=>e.nodes[t]),h=e.initNodes;o.forEach(e=>{r.has(e.name)&&a.push(e)}),e.weights.forEach(e=>{r.has(e.name)&&a.push(e)}),null!=h&&h.forEach(e=>{r.has(e.name)&&a.push(e)});const l=new Set,c=[];for(;a.length>0;){const e=a.pop();l.add(e.name),t[e.name]||c.push(e),e.children.forEach(e=>{!l.has(e.name)&&r.has(e.name)&&e.inputs.every(e=>l.has(e.name))&&a.push(e)})}return c}const a=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],o=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],h=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function l(e){return a.indexOf(e.op)>=0}function c(e){return o.indexOf(e.op)>=0}function p(e){return h.indexOf(e.op)>=0}},737:function(e,t,s){"use strict";s.d(t,"a",(function(){return TensorArray}));var n=s(0),r=s(78);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class TensorArray{constructor(e,t,s,r,i,a,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Object(n.af)(0),Object(n.qe)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),Object(r.a)(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,Object(n.qe)(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,s)=>this.write(e,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Object(n.wf)([],[0].concat(this.elementShape));const s=this.readMany(e);return Object(r.a)(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Object(n.rf)(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Object(n.wf)([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const s=this.readMany(t);return Object(r.a)(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Object(n.Ld)(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Object(n.Ff)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(e=>(s+=e,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=0===s?0:t.size/s,a=[];Object(n.Af)(()=>{t=Object(n.Ye)(t,[1,s,i]);for(let s=0;s<e.length;++s){const o=[0,0===s?0:r[s-1],0],h=[1,e[s],i];a[s]=Object(n.Ye)(Object(n.gf)(t,o,h),this.elementShape)}return a});const o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,a)}}},756:function(e,t,s){"use strict";s.d(t,"a",(function(){return ResourceManager}));class ResourceManager{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}},78:function(e,t,s){"use strict";s.d(t,"a",(function(){return r})),s.d(t,"b",(function(){return a})),s.d(t,"c",(function(){return o}));var n=s(0);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(e,t,s=""){if("number"!=typeof e&&"number"!=typeof t){n.Hf.assert(e.length===t.length,()=>s+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){const i=e[r],a=t[r];n.Hf.assert(i<0||a<0||i===a,()=>s+` Shapes ${e} and ${t} must match`)}}}function i(e){return"number"!=typeof e&&!e.some(e=>e<0)}function a(e,t,s){let n=o(e,s);const r=!i(n);if(r&&0===t.length)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: "+n);if(r&&t.forEach(e=>{n=o(e.shape,n)}),!i(n))throw new Error("Non-fully-defined elementShape: "+n);return n}function o(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const s=[];for(let n=0;n<e.length;++n){const r=e[n],i=t[n];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);s[n]=r>=0?r:i}return s}}}]);