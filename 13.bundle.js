(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{166:function(e,t,s){"use strict";s.d(t,"b",(function(){return m})),s.d(t,"a",(function(){return Sequential}));var i=s(0),n=s(136),o=s(148),a=s(20),l=s(149),u=s(8),h=s(96),r=s(12),d=s(200),p=s(16);async function m(e,t){if(null==t&&(t={}),"string"==typeof e){const s=i.pe.getLoadHandlers(e,t);if(0===s.length)s.push(i.pe.browserHTTPRequest(e,t));else if(s.length>1)throw new u.e(`Found more than one (${s.length}) load handlers for URL '${e}'`);e=s[0]}return async function(e,t,s){null==s&&(s={});if(null==e.load)throw new u.e("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const n=await e.load();let o=n.modelTopology;null!=o.model_config&&(o=o.model_config);const a=null==s.strict||s.strict,l=null!=n.weightData&&null!=n.weightSpecs&&a,r=Object(h.a)(Object(d.a)(o),t,l),p=n.trainingConfig;null!=p&&r.loadTrainingConfig(p);null!=n.userDefinedMetadata&&r.setUserDefinedMetadata(n.userDefinedMetadata);if(null!=n.weightData){if(null==n.weightSpecs)throw new u.e("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=function(e,t){const s=i.pe.decodeWeights(e,t),n={},o=[];return t.forEach(e=>{"optimizer"===e.group?o.push({name:e.name,tensor:s[e.name]}):n[e.name]=s[e.name]}),{modelWeights:n,optimizerWeights:o}}(n.weightData,n.weightSpecs);r.loadWeights(e,a),null!=r.optimizer&&t.length>0&&await r.optimizer.setWeights(t),Object(i.Yd)(e),Object(i.Yd)(t.map(e=>e.tensor))}return r}(e,void 0,t)}class Sequential extends l.a{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Object(n.b)("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new u.e("Negative dimension size caused by adding layer "+e.name+" with input shape ["+e.inboundNodes[0].inputTensors[0].shape+"]")}add(e){const t=e instanceof Sequential||e instanceof l.a;let s;if(t){if(s=e,1!==s.outputs.length)throw new u.e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new u.e("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new u.e("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=Object(o.a)({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new u.e(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new u.e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Object(a.e)(this.outputs[0])}this.inboundNodes=[],new a.c({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:r.j(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Object(p.a)(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new l.a({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new u.d("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new u.d("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new u.d("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new u.d("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},n=!1){let o,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new u.e("Legacy serialization format not supported yet.");o=t}else i.Hf.assert(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=t.layers,delete t.layers,a=t;const l=new e(a);if(!(l instanceof Sequential))throw new u.c("Sequential.fromConfig called on non-Sequential input: "+l);for(const e of o){const t=void 0,s=Object(h.a)(e,t,n);n&&s.setFastWeightInitDuringBuild(!0),l.add(s)}return l}set stopTraining(e){if(null==this.model)throw new u.e("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new u.e("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}Sequential.className="Sequential",i.df.registerClass(Sequential)}}]);