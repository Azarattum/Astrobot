(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{155:function(t,e,i){"use strict";i.d(e,"c",(function(){return Dropout})),i.d(e,"i",(function(){return SpatialDropout1D})),i.d(e,"b",(function(){return Dense})),i.d(e,"d",(function(){return Flatten})),i.d(e,"a",(function(){return Activation})),i.d(e,"g",(function(){return RepeatVector})),i.d(e,"h",(function(){return Reshape})),i.d(e,"f",(function(){return Permute})),i.d(e,"e",(function(){return Masking}));var s=i(0),n=i(74),a=i(21),r=i(39),o=i(20),l=i(8),u=i(26),c=i(30),h=i(12),p=i(47),b=i(16);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Dropout extends o.b{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,i=[];for(let t=0;t<this.noiseShape.length;++t)i.push(null==this.noiseShape[t]?e[t]:this.noiseShape[t]);return i}call(t,e){return Object(s.Af)(()=>{this.invokeCallHook(t,e);const i=Object(b.b)(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,s=this.getNoiseShape(i);return a.m(()=>a.g(i,this.rate,s,this.seed),()=>i,t)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}Dropout.className="Dropout",s.df.registerClass(Dropout);class SpatialDropout1D extends Dropout{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}SpatialDropout1D.className="SpatialDropout1D",s.df.registerClass(SpatialDropout1D);class Dense extends o.b{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Object(h.b)(this.units,"units"),this.activation=Object(n.b)(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=Object(u.q)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Object(u.q)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Object(r.e)(t.kernelConstraint),this.biasConstraint=Object(r.e)(t.biasConstraint),this.kernelRegularizer=Object(c.b)(t.kernelRegularizer),this.biasRegularizer=Object(c.b)(t.biasRegularizer),this.activityRegularizer=Object(c.b)(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=Object(b.a)(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=Object(b.a)(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return Object(s.Af)(()=>{this.invokeCallHook(t,e);const i=Object(b.b)(t),s=Object(h.i)(this.activation.getClassName());let n;return null!=s?n=a.f(i,this.kernel.read(),s,this.bias?this.bias.read():null):(n=a.f(i,this.kernel.read()),null!=this.bias&&(n=a.b(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n})}getConfig(){const t={units:this.units,activation:Object(n.c)(this.activation),useBias:this.useBias,kernelInitializer:Object(u.r)(this.kernelInitializer),biasInitializer:Object(u.r)(this.biasInitializer),kernelRegularizer:Object(c.e)(this.kernelRegularizer),biasRegularizer:Object(c.e)(this.biasRegularizer),activityRegularizer:Object(c.e)(this.activityRegularizer),kernelConstraint:Object(r.f)(this.kernelConstraint),biasConstraint:Object(r.f)(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}Dense.className="Dense",s.df.registerClass(Dense);class Flatten extends o.b{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Object(b.a)(t);for(const e of t.slice(1))if(null==e)throw new l.e(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Object(p.a)(t,1)]}call(t,e){return Object(s.Af)(()=>{this.invokeCallHook(t,e);let i=Object(b.b)(t);if("channelsFirst"===this.dataFormat&&i.rank>1){const t=[0];for(let e=2;e<i.rank;++e)t.push(e);t.push(1),i=Object(s.Df)(i,t)}return a.a(i)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}Flatten.className="Flatten",s.df.registerClass(Flatten);class Activation extends o.b{constructor(t){super(t),this.supportsMasking=!0,this.activation=Object(n.b)(t.activation)}call(t,e){return Object(s.Af)(()=>{this.invokeCallHook(t,e);const i=Object(b.b)(t);return this.activation.apply(i)})}getConfig(){const t={activation:Object(n.c)(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}Activation.className="Activation",s.df.registerClass(Activation);class RepeatVector extends o.b{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return Object(s.Af)(()=>(t=Object(b.b)(t),a.o(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}RepeatVector.className="RepeatVector",s.df.registerClass(RepeatVector);class Reshape extends o.b{constructor(t){super(t),this.targetShape=t.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const i="Total size of new array must be unchanged.",s=e.slice();let n=1,a=null;for(let t=0;t<s.length;++t){const e=s[t];if(this.isUnknown(e)){if(null!==a)throw new l.e("Can only specifiy one unknown dimension.");a=t}else n*=e}const r=Object(p.a)(t);if(null!==a){if(0===n||r%n!=0)throw new l.e(i);s[a]=r/n}else if(r!==n)throw new l.e(i);return s}computeOutputShape(t){let e=!1;for(let i=0;i<t.length;++i)if(this.isUnknown(t[i])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return Object(s.Af)(()=>{this.invokeCallHook(t,e);const i=Object(b.b)(t),n=i.shape,a=n.slice(0,1).concat(this.fixUnknownDimension(n.slice(1),this.targetShape));return Object(s.Ye)(i,a)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}Reshape.className="Reshape",s.df.registerClass(Reshape);class Permute extends o.b{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+t.dims+" instead.");const e=Object(p.e)(1,t.dims.length+1);if(!s.Hf.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new o.a({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=Object(b.a)(t)).slice();return this.dims.forEach((i,s)=>{e[s+1]=t[i]}),e}call(t,e){return Object(s.Df)(Object(b.b)(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}Permute.className="Permute",s.df.registerClass(Permute);class Masking extends o.b{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const i=Object(b.b)(t);return Object(s.vd)(Object(s.Le)(i,this.maskValue),-1)}call(t,e){return Object(s.Af)(()=>{this.invokeCallHook(t,e);const i=Object(b.b)(t),n=Object(s.vd)(Object(s.Le)(i,this.maskValue),-1,!0);return Object(s.Ie)(i,Object(s.Id)(n,i.dtype))})}}Masking.className="Masking",s.df.registerClass(Masking)}}]);