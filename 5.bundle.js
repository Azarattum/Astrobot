(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{452:function(i,t,e){"use strict";e.d(t,"a",(function(){return BatchNormalization})),e.d(t,"b",(function(){return LayerNormalization}));var a=e(0),s=e(39),n=e(20),r=e(8),l=e(26),h=e(30),o=e(12),c=e(47),m=e(16);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function u(i,t,e,s,n,l=.001){let h;if(2===i.rank)h=a.Bd(i,t,e,s,n,l);else if(3===i.rank)h=a.Cd(i,t,e,s,n,l);else{if(4!==i.rank)throw new r.c(`batchNormalization is not implemented for array of rank ${i.rank} yet`);h=a.Dd(i,t,e,s,n,l)}return h}function g(i,t,e,s,n=.001){return a.Hf.arraysEqual(s.slice().sort(),c.e(0,i.rank-1))?function(i,t,e,s,n=.001){return Object(a.Af)(()=>{const r=a.He(i,s),l=r.mean,h=r.variance;return[u(i,l,h,e,t,n),l,h]})}(i,t,e,s,n):function(i,t,e,s,n=.001){return Object(a.Af)(()=>{const r=a.He(i,s),l=r.mean,h=r.variance,o=[];for(const t of c.e(0,i.rank))-1!==s.indexOf(t)?o.push(1):o.push(i.shape[t]);const m=Object(a.Ye)(l,o),g=Object(a.Ye)(h,o),b=null==t?null:Object(a.Ye)(t,o),f=null==e?null:Object(a.Ye)(e,o);return[u(i,m,g,f,b,n),l,h]})}(i,t,e,s,n)}class BatchNormalization extends n.b{constructor(i){null==i&&(i={}),super(i),this.supportsMasking=!0,this.axis=null==i.axis?-1:i.axis,this.momentum=null==i.momentum?.99:i.momentum,this.epsilon=null==i.epsilon?.001:i.epsilon,this.center=null==i.center||i.center,this.scale=null==i.scale||i.scale,this.betaInitializer=Object(l.q)(i.betaInitializer||"zeros"),this.gammaInitializer=Object(l.q)(i.gammaInitializer||"ones"),this.movingMeanInitializer=Object(l.q)(i.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Object(l.q)(i.movingVarianceInitializer||"ones"),this.betaConstraint=Object(s.e)(i.betaConstraint),this.gammaConstraint=Object(s.e)(i.gammaConstraint),this.betaRegularizer=Object(h.b)(i.betaRegularizer),this.gammaRegularizer=Object(h.b)(i.gammaRegularizer)}build(i){i=Object(m.a)(i);const t=this.axis>=0?this.axis:this.axis+i.length,e=i[t];if(null==e)throw new r.e(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape `+JSON.stringify(i)+".");this.inputSpec=[new n.a({ndim:i.length,axes:{[t]:e}})];const a=[e];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(i,t){return Object(a.Af)(()=>{const e=null!=t.training&&t.training,s=Object(m.b)(i),n=s.shape,r=n.length,l=c.e(0,r),h=this.axis>=0?this.axis:this.axis+r;l.splice(h,1);const b=o.j(1,r);b[h]=n[h];const f=l.slice();f.sort();const z=!a.Hf.arraysEqual(f,c.e(0,r).slice(0,r-1));if(!e)return(()=>{if(z){const i=Object(a.Ye)(this.movingMean.read(),b),t=Object(a.Ye)(this.movingVariance.read(),b),e=this.center?Object(a.Ye)(this.beta.read(),b):null,n=this.scale?Object(a.Ye)(this.gamma.read(),b):null;return u(s,i,t,e,n,this.epsilon)}return u(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,x]=g(s,this.gamma.read(),this.beta.read(),l,this.epsilon),O=(i,t,e)=>{a.Af(()=>{const s=1-e,n=i.read(),r=a.Ie(a.sf(n,t),s);i.write(a.sf(n,r))})};return(()=>{O(this.movingMean,p,this.momentum),O(this.movingVariance,x,this.momentum)})(),d})}getConfig(){const i={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Object(l.r)(this.betaInitializer),gammaInitializer:Object(l.r)(this.gammaInitializer),movingMeanInitializer:Object(l.r)(this.movingMeanInitializer),movingVarianceInitializer:Object(l.r)(this.movingVarianceInitializer),betaRegularizer:Object(h.e)(this.betaRegularizer),gammaRegularizer:Object(h.e)(this.gammaRegularizer),betaConstraint:Object(s.f)(this.betaConstraint),gammaConstraint:Object(s.f)(this.gammaConstraint)},t=super.getConfig();return Object.assign(i,t),i}}BatchNormalization.className="BatchNormalization",a.df.registerClass(BatchNormalization);class LayerNormalization extends n.b{constructor(i){if(null==i&&(i={}),super(i),this.axis=null==i.axis?-1:i.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received "+this.axis)}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, but received "+JSON.stringify(this.axis));for(const i of this.axis)if(!Number.isInteger(i))throw new Error("Expected axis to be an array of integers, but received "+JSON.stringify(this.axis))}this.epsilon=null==i.epsilon?.001:i.epsilon,this.center=null==i.center||i.center,this.scale=null==i.scale||i.scale,this.betaInitializer=Object(l.q)(i.betaInitializer||"zeros"),this.gammaInitializer=Object(l.q)(i.gammaInitializer||"ones"),this.betaRegularizer=Object(h.b)(i.betaRegularizer),this.gammaRegularizer=Object(h.b)(i.gammaRegularizer),this.supportsMasking=!0}build(i){const t=(i=Object(m.a)(i)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error("Invalid axis: "+i);if(this.axis.length!==o.q(this.axis).length)throw new Error("Found duplicate axes in: "+this.axis);const e=this.axis.map(t=>i[t]);this.scale?this.gamma=this.addWeight("gamma",e,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",e,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(i,t){const e=Object(m.b)(i),s=e.shape,n=s.length;return Object(a.Af)(()=>{let{mean:i,variance:t}=Object(a.He)(e,this.axis,!0);const r=o.j(1,n);for(const i of this.axis)r[i]=s[i];const l=i=>null!=i&&i.shape.length!==n?a.Ye(i,r):i;let h=this.scale?l(this.gamma.read()):null,c=this.center?l(this.beta.read()):null;const m=[],g=[];for(let i=0;i<n;++i)-1!==this.axis.indexOf(i)?(m.push(s[i]),g.push(1)):(m.push(1),g.push(s[i]));return i=a.Bf(i,m),t=a.Bf(t,m),null!=h&&(h=a.Bf(h,g)),null!=c&&(c=a.Bf(c,g)),u(e,i,t,c,h,this.epsilon)})}getConfig(){const i={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Object(l.r)(this.betaInitializer),gammaInitializer:Object(l.r)(this.gammaInitializer),betaRegularizer:Object(h.e)(this.betaRegularizer),gammaRegularizer:Object(h.e)(this.gammaRegularizer)},t=super.getConfig();return Object.assign(i,t),i}}LayerNormalization.className="LayerNormalization",a.df.registerClass(LayerNormalization)}}]);