(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{190:function(e,t,n){"use strict";n.d(t,"a",(function(){return Add})),n.d(t,"g",(function(){return Multiply})),n.d(t,"b",(function(){return Average})),n.d(t,"e",(function(){return Maximum})),n.d(t,"f",(function(){return Minimum})),n.d(t,"c",(function(){return Concatenate})),n.d(t,"d",(function(){return Dot}));var s=n(0),r=n(21),i=n(20),a=n(8),l=n(52),u=n(12),o=n(47),h=n(16);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Merge extends i.b{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new a.c}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let s=0;s<t.length;++s){const r=e[e.length-t.length+s],i=t[s];if(null==r||null==i||r<0||i<0)n.push(null);else if(1===r)n.push(i);else if(1===i)n.push(r);else{if(r!==i)throw new a.e("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Object(h.a)(e)]),(e=e).length<2)throw new a.e(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=u.q(t),t.length>1)throw new a.e(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const s=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}const s=e.map(e=>e.length);-1===e.indexOf(null)&&1===u.q(s).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Object(s.Af)(()=>{if(e=e,this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const s=o.c(n);for(let n of e){const e=n.rank;for(let t=0;t<s-e;++t)n=r.i(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,i=e[0],a=e.slice(1).concat([i]);let l=s.Ye(r,[i].concat(o.a(e.slice(1))));l=s.Df(l,[1,0]),l=s.Ye(l,a),t.push(l),n=!0}else if(e>1){const i=o.e(1,e).concat([0]);t.push(s.Df(r,i)),n=!0}else t.push(r)}let r=this.mergeFunction(t);const i=r.rank;if(n)if(null==i){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=s.Ye(s.Df(s.Ye(r,[-1,t]),[1,0]),n)}else if(i>1){const e=[i-1].concat(o.e(0,i-1));r=s.Df(r,e)}return r}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const s=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=u.q(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return s.Af(()=>{if(null==t)return null;if(!Array.isArray(t))throw new a.e("`mask` should be an Array");if(!Array.isArray(e))throw new a.e("`inputs` should be an Array");if(t.length!==e.length)throw new a.e(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:s.ge(e,0)))[0];for(let e=1;e<t.length-1;++e)n=s.xe(n,t[e]);return n})}}class Add extends Merge{constructor(e){super(e)}mergeFunction(e){return Object(s.Af)(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=s.td(t,e[n]);return t})}}Add.className="Add",s.df.registerClass(Add);class Multiply extends Merge{constructor(e){super(e)}mergeFunction(e){return Object(s.Af)(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=s.Ie(t,e[n]);return t})}}Multiply.className="Multiply",s.df.registerClass(Multiply);class Average extends Merge{constructor(e){super(e)}mergeFunction(e){return Object(s.Af)(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=s.td(t,e[n]);return s.Ie(1/e.length,t)})}}Average.className="Average",s.df.registerClass(Average);class Maximum extends Merge{constructor(e){super(e)}mergeFunction(e){return Object(s.Af)(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=s.Ce(t,e[n]);return t})}}Maximum.className="Maximum",s.df.registerClass(Maximum);class Minimum extends Merge{constructor(e){super(e)}mergeFunction(e){return Object(s.Af)(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=s.Ge(t,e[n]);return t})}}Minimum.className="Minimum",s.df.registerClass(Minimum);class Concatenate extends Merge{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new a.e("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const r=e[t].slice();r.splice(this.axis,1);let i=!1;for(const e of n)if(s.Hf.arraysEqual(e,r)){i=!0;break}i||n.push(r)}if(n.length>1)throw new a.e("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Object(s.Af)(()=>r.e(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new a.e("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[s]||null==e[s]){n[s]=null;break}n[s]+=e[s]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new a.e("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new a.e("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new a.e(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return s.Af(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(s.Id(s.Oe(e[n]),"bool")):t[n].rank<e[n].rank?r.push(s.ge(t[n],-1)):r.push(t[n]);const i=s.Ld(r,this.axis);return s.ud(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function c(e,t){for(;e<0;)e+=t;return e}Concatenate.className="Concatenate",s.df.registerClass(Concatenate);class Dot extends Merge{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){s.Hf.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new a.c("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new a.e(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new a.e(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>c(t,e[n].shape.length)):[c(this.axes,n.shape.length),c(this.axes,r.shape.length)],this.normalize&&(n=Object(l.e)(n,t[0]),r=Object(l.e)(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new a.c("batchDot is not implemented for tensors of 4D or higher rank yet");if(s.Hf.assert(e.shape.length>=2,()=>"batchDot requires the rank of x to be >= 2, but got "+e.shape.length),s.Hf.assert(e.shape.length>=2,()=>"batchDot requires the rank of y to be >= 2, but got "+t.shape.length),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new a.c("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,i=t.shape.length;null==n&&(n=[r-1,i-2]);const l=n;return s.Af(()=>{let n,a;if(r>i){n=r-i;const e=[];for(let t=0;t<n;++t)e.push(1);t=s.Ye(t,t.shape.concat(e))}else if(i>r){n=i-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=s.Ye(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)a=l[0]===l[1]?s.tf(s.Ie(e,t),l[0]):s.tf(s.Ie(s.Df(e,[1,0]),t),l[1]);else{const n=l[0]!==e.shape.length-1,r=l[1]===t.shape.length-1;a=s.ye(e,t,n,r)}if(n>0){let e;e=r>i?r+i-3:r-1;const t=[];for(let s=e;s<e+n;++s)t.push(s);a=s.qf(a,t)}return 1===a.shape.length&&(a=s.ge(a,1)),a})}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[c(this.axes,e.length),c(this.axes,t.length)],n}computeOutputShape(e){s.Hf.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new a.c("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const i=t.concat(n);return 1===i.length&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}Dot.className="Dot",s.df.registerClass(Dot)},415:function(e,t,n){"use strict";n.d(t,"c",(function(){return GaussianNoise})),n.d(t,"b",(function(){return GaussianDropout})),n.d(t,"a",(function(){return AlphaDropout}));var s=n(0),r=n(21),i=n(20),a=n(16);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class GaussianNoise extends i.b{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Object(s.Af)(()=>{this.invokeCallHook(e,t);const n=Object(a.b)(e);return r.m(()=>Object(s.td)(r.n(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}}GaussianNoise.className="GaussianNoise",s.df.registerClass(GaussianNoise);class GaussianDropout extends i.b{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Object(s.Af)(()=>{this.invokeCallHook(e,t);const n=Object(a.b)(e);if(this.rate>0&&this.rate<1){const e=()=>{const e=Math.sqrt(this.rate/(1-this.rate));return Object(s.Ie)(n,r.n(n.shape,1,e))};return r.m(e,()=>n,t.training||!1)}return n})}}GaussianDropout.className="GaussianDropout",s.df.registerClass(GaussianDropout);class AlphaDropout extends i.b{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Object(a.b)(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Object(s.Af)(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),i=()=>{const t=Object(a.b)(e),i=-1.7580993408473766;let l=Object(s.ne)(Object(s.Te)(n),this.rate);l=r.c(l,"float32");const u=((1-this.rate)*(1+this.rate*i**2))**-.5,o=-u*i*this.rate,h=Object(s.td)(Object(s.Ie)(t,l),Object(s.Ie)(Object(s.td)(l,-1),i));return Object(s.td)(Object(s.Ie)(h,u),o)};return r.m(i,()=>Object(a.b)(e),t.training||!1)}return e})}}AlphaDropout.className="AlphaDropout",s.df.registerClass(AlphaDropout)},707:function(e,t,n){"use strict";n.d(t,"a",(function(){return Embedding}));var s=n(0),r=n(21),i=n(39),a=n(20),l=n(8),u=n(26),o=n(30),h=n(12),c=n(16);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Embedding extends a.b{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(h.o(e.inputLength))}this.inputDim=e.inputDim,h.b(this.inputDim,"inputDim"),this.outputDim=e.outputDim,h.b(this.outputDim,"outputDim"),this.embeddingsInitializer=Object(u.q)(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Object(o.b)(e.embeddingsRegularizer),this.activityRegularizer=Object(o.b)(e.activityRegularizer),this.embeddingsConstraint=Object(i.e)(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Object(s.Af)(()=>this.maskZero?(e=Object(c.b)(e),Object(s.Le)(e,Object(s.Nf)(e))):null)}computeOutputShape(e){if(e=Object(c.a)(e),null==this.inputLength)return[...e,this.outputDim];const t=h.o(this.inputLength);if(t.length!==e.length-1)throw new l.e(`"inputLength" is ${this.inputLength}, but received input shape has shape `+e);{let n=0;for(let s=0;s<t.length;++s){const r=t[s],i=e[s+1];if(null!=r&&null!=i&&r!==i)throw new l.e(`"inputLength" is ${this.inputLength}, but received input shape has shape `+e);null==r&&(t[n]=i),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Object(s.Af)(()=>{this.invokeCallHook(e,t);let n=Object(c.b)(e);"int32"!==n.dtype&&(n=r.c(n,"int32"));const i=r.k(this.embeddings.read(),Object(s.Ye)(n,[n.size]));return Object(s.Ye)(i,Object(c.a)(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Object(u.r)(this.embeddingsInitializer),embeddingsRegularizer:Object(o.e)(this.embeddingsRegularizer),activityRegularizer:Object(o.e)(this.activityRegularizer),embeddingsConstraint:Object(i.f)(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}Embedding.className="Embedding",s.df.registerClass(Embedding)}}]);