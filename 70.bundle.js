(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{709:function(t,e,i){"use strict";i.d(e,"a",(function(){return Rescaling}));var s=i(20),r=i(0),n=i(16),l=i(21);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Rescaling extends s.b{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return Object(r.Af)(()=>("float32"!==(t=Object(n.b)(t)).dtype&&(t=l.c(t,"float32")),Object(r.td)(Object(r.Ie)(t,this.scale),this.offset)))}}Rescaling.className="Rescaling",r.df.registerClass(Rescaling)},71:function(t,e,i){"use strict";i.d(e,"l",(function(){return I})),i.d(e,"k",(function(){return R})),i.d(e,"e",(function(){return RNN})),i.d(e,"f",(function(){return RNNCell})),i.d(e,"h",(function(){return SimpleRNNCell})),i.d(e,"g",(function(){return SimpleRNN})),i.d(e,"b",(function(){return GRUCell})),i.d(e,"a",(function(){return GRU})),i.d(e,"d",(function(){return LSTMCell})),i.d(e,"c",(function(){return LSTM})),i.d(e,"i",(function(){return StackedRNNCells})),i.d(e,"j",(function(){return C}));var s=i(0),r=i(74),n=i(21),l=i(31),a=i(39),u=i(20),o=i(8),c=i(26),h=i(30),p=i(12),g=i(47),d=i(16),b=i(132),f=i(96);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function I(t,e,i,s){if(Array.isArray(t)){if(null!=e||null!=i)throw new o.e("When inputs is an array, neither initialState or constants should be provided");null!=s&&(i=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=r(e),constants:i=r(i)}}function R(t,e,i,r=!1,n,l,a=!1,u=!1){return s.Af(()=>{const c=e.shape.length;if(c<3)throw new o.e(`Input should be at least 3D, but is ${c}D.`);const h=[1,0].concat(g.e(2,c));if(e=s.Df(e,h),null!=l)throw new o.c("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=n&&((n=s.Id(s.Id(n,"bool"),"float32")).rank===c-1&&(n=s.ge(n,-1)),n=s.Df(n,h)),r&&(e=s.Ze(e,0),null!=n&&(n=s.Ze(n,0)));const p=[];let d,b=i;const f=e.shape[0],I=s.Ff(e);let R,C;null!=n&&(R=s.Ff(n));for(let e=0;e<f;++e){const i=I[e],r=s.Af(()=>t(i,b));if(null==n)d=r[0],b=r[1];else{const t=s.Af(()=>{const t=R[e],i=s.sf(s.Oe(t),t);return{output:s.td(s.Ie(r[0],t),s.Ie(b[0],i)),newStates:b.map((e,n)=>s.td(s.Ie(r[1][n],t),s.Ie(e,i)))}});d=t.output,b=t.newStates}u&&p.push(d)}if(u){const t=1;C=s.rf(p,t)}return[d,C,b]})}class RNN extends u.b{constructor(t){let e;if(super(t),null==t.cell)throw new o.e("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new StackedRNNCells({cells:t.cell}):t.cell,null==e.stateSize)throw new o.e("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new u.a({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return g.e(0,t).map(t=>null)}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Object(d.c)(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const i=e[0];let s;if(s=this.returnSequences?[t[0],t[1],i]:[t[0],i],this.returnState){const i=[];for(const s of e)i.push([t[0],s]);return[s].concat(i)}return s}computeMask(t,e){return s.Af(()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let i=0;i<t;++i)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new o.c("Constants support is not implemented in RNN yet.");Object(d.c)(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,i=t.slice(2);this.inputSpec[0]=new u.a({shape:[e,null,...i]});const r=[t[0]].concat(t.slice(2));let n;if(this.cell.build(r),n=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!s.Hf.arraysEqual(this.stateSpec.map(t=>t.shape[t.shape.length-1]),n))throw new o.e(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is `+this.cell.stateSize)}else this.stateSpec=n.map(t=>new u.a({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){Object(s.Af)(()=>{if(!this.stateful)throw new o.b("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape[0];if(null==i)throw new o.e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>s.Mf([i,t])):this.states_=[s.Mf([i,this.cell.stateSize])];else if(null==t)s.Yd(this.states_),null!=this.keptStates&&(s.Yd(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>s.Mf([i,t])):this.states_[0]=s.Mf([i,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new o.e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: `+t);!0===e?this.keptStates.push(this.states_.slice()):s.Yd(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],n=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,l=[i,n];if(!s.Hf.arraysEqual(r.shape,l))throw new o.e(`State ${e} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${r.shape}`);this.states_[e]=r}}this.states_=this.states_.map(t=>s.qe(t.clone()))})}apply(t,e){let i=null==e?null:e.initialState,s=null==e?null:e.constants;null==e&&(e={});const r=I(t,i,s,this.numConstants);t=r.inputs,i=r.initialState,s=r.constants;let n=[],l=[];if(null!=i){e.initialState=i,n=n.concat(i),this.stateSpec=[];for(const t of i)this.stateSpec.push(new u.a({shape:t.shape}));l=l.concat(this.stateSpec)}null!=s&&(e.constants=s,n=n.concat(s),this.numConstants=s.length);if(n[0]instanceof u.d){const i=[t].concat(n),s=this.inputSpec.concat(l),r=this.inputSpec;this.inputSpec=s;const a=super.apply(i,e);return this.inputSpec=r,a}return super.apply(t,e)}call(t,e){return Object(s.Af)(()=>{const i=null==e?null:e.mask,s=null==e?null:e.training;let r=null==e?null:e.initialState;t=Object(d.b)(t),null==r&&(r=this.stateful?this.states_:this.getInitialState(t));const n=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==n)throw new o.e(`RNN Layer has ${n} state(s) but was passed `+r.length+" initial state(s).");this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:s},a=R((t,e)=>{const i=this.cell.call([t].concat(e),l);return[i[0],i.slice(1)]},t,r,this.goBackwards,i,null,this.unroll,this.returnSequences),u=a[0],c=a[1],h=a[2];this.stateful&&this.resetStates(h,s);const p=this.returnSequences?c:u;return this.returnState?[p].concat(h):p})}getInitialState(t){return Object(s.Af)(()=>{let e=s.Mf(t.shape);return e=s.tf(e,[1,2]),e=n.i(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>t>1?n.t(e,[1,t]):e):this.cell.stateSize>1?[n.t(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===RNN.className&&(e.cell={className:this.cell.getClassName(),config:i}),Object.assign(Object.assign(Object.assign({},i),t),e)}static fromConfig(t,e,i={}){const s=e.cell,r=Object(f.a)(s,i);return new t(Object.assign(e,{cell:r}))}}RNN.className="RNN",s.df.registerClass(RNN);class RNNCell extends u.b{}class SimpleRNNCell extends RNNCell{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Object(p.b)(this.units,"units"),this.activation=Object(r.b)(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Object(c.q)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Object(c.q)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Object(c.q)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Object(h.b)(t.kernelRegularizer),this.recurrentRegularizer=Object(h.b)(t.recurrentRegularizer),this.biasRegularizer=Object(h.b)(t.biasRegularizer),this.kernelConstraint=Object(a.e)(t.kernelConstraint),this.recurrentConstraint=Object(a.e)(t.recurrentConstraint),this.biasConstraint=Object(a.e)(t.biasConstraint),this.dropout=g.d([1,g.c([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=g.d([1,g.c([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Object(d.a)(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Object(s.Af)(()=>{if(2!==(t=t).length)throw new o.e(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let i=t[1];t=t[0];const r=null!=e.training&&e.training;let l;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=C({ones:()=>s.Oe(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=C({ones:()=>s.Oe(i),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,u=this.recurrentDropoutMask;l=null!=a?n.f(s.Ie(t,a),this.kernel.read()):n.f(t,this.kernel.read()),null!=this.bias&&(l=n.b(l,this.bias.read())),null!=u&&(i=s.Ie(i,u));let c=s.td(l,n.f(i,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Object(r.c)(this.activation),useBias:this.useBias,kernelInitializer:Object(c.r)(this.kernelInitializer),recurrentInitializer:Object(c.r)(this.recurrentInitializer),biasInitializer:Object(c.r)(this.biasInitializer),kernelRegularizer:Object(h.e)(this.kernelRegularizer),recurrentRegularizer:Object(h.e)(this.recurrentRegularizer),biasRegularizer:Object(h.e)(this.biasRegularizer),activityRegularizer:Object(h.e)(this.activityRegularizer),kernelConstraint:Object(a.f)(this.kernelConstraint),recurrentConstraint:Object(a.f)(this.recurrentConstraint),biasConstraint:Object(a.f)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}SimpleRNNCell.className="SimpleRNNCell",s.df.registerClass(SimpleRNNCell);class SimpleRNN extends RNN{constructor(t){t.cell=new SimpleRNNCell(t),super(t)}call(t,e){return Object(s.Af)(()=>{null!=this.cell.dropoutMask&&(s.Yd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.Yd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=null==e?null:e.mask,r=null==e?null:e.training,n=null==e?null:e.initialState;return super.call(t,{mask:i,training:r,initialState:n})})}static fromConfig(t,e){return new t(e)}}SimpleRNN.className="SimpleRNN",s.df.registerClass(SimpleRNN);class GRUCell extends RNNCell{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new o.e("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Object(p.b)(this.units,"units"),this.activation=Object(r.b)(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Object(r.b)(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Object(c.q)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Object(c.q)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Object(c.q)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Object(h.b)(t.kernelRegularizer),this.recurrentRegularizer=Object(h.b)(t.recurrentRegularizer),this.biasRegularizer=Object(h.b)(t.biasRegularizer),this.kernelConstraint=Object(a.e)(t.kernelConstraint),this.recurrentConstraint=Object(a.e)(t.recurrentConstraint),this.biasConstraint=Object(a.e)(t.biasConstraint),this.dropout=g.d([1,g.c([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=g.d([1,g.c([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=Object(d.a)(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Object(s.Af)(()=>{if(2!==(t=t).length)throw new o.e("GRUCell expects 2 input Tensors (inputs, h, c), got "+t.length+".");const i=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=C({ones:()=>s.Oe(t),rate:this.dropout,training:i,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=C({ones:()=>s.Oe(r),rate:this.recurrentDropout,training:i,count:3,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,a=this.recurrentDropoutMask;let u,c,h;0<this.dropout&&this.dropout<1&&(t=s.Ie(t,l[0]));let p=n.f(t,this.kernel.read());this.useBias&&(p=n.b(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=s.Ie(r,a[0]));const g=this.recurrentKernel.read(),[d,b]=s.of(g,[2*this.units,this.units],g.rank-1),f=n.f(r,d),[I,R,O]=s.of(p,3,p.rank-1),[k,z]=s.of(f,2,f.rank-1);u=this.recurrentActivation.apply(s.td(I,k)),c=this.recurrentActivation.apply(s.td(R,z));const A=n.f(s.Ie(c,r),b);h=this.activation.apply(s.td(O,A));const N=s.td(s.Ie(u,r),s.Ie(s.td(1,s.Je(u)),h));return[N,N]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Object(r.c)(this.activation),recurrentActivation:Object(r.c)(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Object(c.r)(this.kernelInitializer),recurrentInitializer:Object(c.r)(this.recurrentInitializer),biasInitializer:Object(c.r)(this.biasInitializer),kernelRegularizer:Object(h.e)(this.kernelRegularizer),recurrentRegularizer:Object(h.e)(this.recurrentRegularizer),biasRegularizer:Object(h.e)(this.biasRegularizer),activityRegularizer:Object(h.e)(this.activityRegularizer),kernelConstraint:Object(a.f)(this.kernelConstraint),recurrentConstraint:Object(a.f)(this.recurrentConstraint),biasConstraint:Object(a.f)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}GRUCell.className="GRUCell",s.df.registerClass(GRUCell);class GRU extends RNN{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new GRUCell(t),super(t)}call(t,e){return Object(s.Af)(()=>{null!=this.cell.dropoutMask&&(s.Yd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.Yd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=null==e?null:e.mask,r=null==e?null:e.training,n=null==e?null:e.initialState;return super.call(t,{mask:i,training:r,initialState:n})})}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}GRU.className="GRU",s.df.registerClass(GRU);class LSTMCell extends RNNCell{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Object(p.b)(this.units,"units"),this.activation=Object(r.b)(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Object(r.b)(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=Object(c.q)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Object(c.q)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Object(c.q)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Object(h.b)(t.kernelRegularizer),this.recurrentRegularizer=Object(h.b)(t.recurrentRegularizer),this.biasRegularizer=Object(h.b)(t.biasRegularizer),this.kernelConstraint=Object(a.e)(t.kernelConstraint),this.recurrentConstraint=Object(a.e)(t.recurrentConstraint),this.biasConstraint=Object(a.e)(t.biasConstraint),this.dropout=g.d([1,g.c([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=g.d([1,g.c([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const i=(t=Object(d.a)(t))[t.length-1];let s;if(this.kernel=this.addWeight("kernel",[i,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,i=this.units;s=new((e=class CustomInit extends c.g{apply(e,s){const r=t.apply([i]),l=(new c.j).apply([i]),a=t.apply([2*i]);return n.d(n.d(r,l),a)}}).className="CustomInit",e)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return Object(s.Af)(()=>{const i=null!=e.training&&e.training;if(3!==(t=t).length)throw new o.e("LSTMCell expects 3 input Tensors (inputs, h, c), got "+t.length+".");let r=t[1];const l=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=C({ones:()=>s.Oe(t),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=C({ones:()=>s.Oe(r),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,u=this.recurrentDropoutMask;let c,h,p,g;0<this.dropout&&this.dropout<1&&(t=s.Ie(t,a[0]));let d=n.f(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=s.Ie(r,u[0])),d=s.td(d,n.f(r,this.recurrentKernel.read())),this.useBias&&(d=n.b(d,this.bias.read()));const[b,f,I,R]=s.of(d,4,d.rank-1);c=this.recurrentActivation.apply(b),h=this.recurrentActivation.apply(f),p=s.td(s.Ie(h,l),s.Ie(c,this.activation.apply(I))),g=this.recurrentActivation.apply(R);const O=s.Ie(g,this.activation.apply(p));return[O,O,p]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Object(r.c)(this.activation),recurrentActivation:Object(r.c)(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Object(c.r)(this.kernelInitializer),recurrentInitializer:Object(c.r)(this.recurrentInitializer),biasInitializer:Object(c.r)(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Object(h.e)(this.kernelRegularizer),recurrentRegularizer:Object(h.e)(this.recurrentRegularizer),biasRegularizer:Object(h.e)(this.biasRegularizer),activityRegularizer:Object(h.e)(this.activityRegularizer),kernelConstraint:Object(a.f)(this.kernelConstraint),recurrentConstraint:Object(a.f)(this.recurrentConstraint),biasConstraint:Object(a.f)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}LSTMCell.className="LSTMCell",s.df.registerClass(LSTMCell);class LSTM extends RNN{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new LSTMCell(t),super(t)}call(t,e){return Object(s.Af)(()=>{null!=this.cell.dropoutMask&&(s.Yd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(s.Yd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const i=null==e?null:e.mask,r=null==e?null:e.training,n=null==e?null:e.initialState;return super.call(t,{mask:i,training:r,initialState:n})})}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}LSTM.className="LSTM",s.df.registerClass(LSTM);class StackedRNNCells extends RNNCell{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return Object(s.Af)(()=>{let i=(t=t).slice(1);const s=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?s.push(i.splice(0,t.stateSize.length)):s.push(i.splice(0,1));s.reverse();const r=[];let n;for(let l=0;l<this.cells.length;++l){const a=this.cells[l];i=s[l],n=0===l?[t[0]].concat(i):[n[0]].concat(i),n=a.call(n,e),r.push(n.slice(1))}i=[];for(const t of r.slice().reverse())i.push(...t);return[n[0]].concat(i)})}build(t){let e;Object(d.c)(t)&&(t=t[0]),t=t,this.cells.forEach((i,s)=>{Object(l.g)("RNNCell_"+s,()=>{i.build(t),e=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map(t=>({className:t.getClassName(),config:t.getConfig()}))};return Object.assign(Object.assign({},t),e)}static fromConfig(t,e,i={}){const s=[];for(const t of e.cells)s.push(Object(f.a)(t,i));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return Object(b.b)(t)}setWeights(t){const e=[];for(const i of this.cells){const s=i.weights.length,r=t.splice(s);for(let t=0;t<i.weights.length;++t)e.push([i.weights[t],r[t]])}Object(b.c)(e)}}function C(t){const{ones:e,rate:i,training:r=!1,count:l=1,dropoutFunc:a}=t,u=()=>null!=a?a(e(),i):n.g(e(),i),o=()=>n.m(u,e,r);if(!l||l<=1)return s.qe(o().clone());return Array(l).fill(void 0).map(o).map(t=>s.qe(t.clone()))}StackedRNNCells.className="StackedRNNCells",s.df.registerClass(StackedRNNCells)},710:function(t,e,i){"use strict";i.d(e,"a",(function(){return CenterCrop}));var s=i(0),r=i(16),n=i(20),l=i(21);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const{resizeBilinear:a,cropAndResize:u}=s.oe;class CenterCrop extends n.b{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,i,n,a,o,c,h){return Object(s.Af)(()=>{let p,g=!1;const d=[e/o,i/c,(n+e)/o,(a+i)/c],b=[];3===t.rank?(g=!0,p=Object(s.rf)([t])):p=t;for(let t=0;t<p.shape[0];t++)b.push(d);const f=Object(s.wf)(b,[b.length,4]),I=Object(s.Ue)(0,b.length,1,"int32"),R=u(p,f,I,[n,a],"nearest");return g?l.c(Object(r.b)(Object(s.Ff)(R)),h):l.c(R,h)})}upsize(t,e,i,r){return Object(s.Af)(()=>{const s=a(t,[e,i]);return l.c(s,r)})}call(t,e){return Object(s.Af)(()=>{const e=Object(r.b)(t),i=e.dtype,s=e.shape,n=s[s.length-3],l=s[s.length-2];let a=0;n!==this.height&&(a=Math.floor((n-this.height)/2));let u=0;return l!==this.width&&(u=Math.floor((l-this.width)/2),0===u&&(u=1)),a>=0&&u>=0?this.centerCrop(e,a,u,this.height,this.width,n,l,i):this.upsize(t,this.height,this.width,i)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const e=(t=Object(r.a)(t)).length-3,i=t.length-2;return t[e]=this.height,t[i]=this.width,t}}CenterCrop.className="CenterCrop",s.df.registerClass(CenterCrop)},711:function(t,e,i){"use strict";i.d(e,"a",(function(){return CategoryEncoding}));var s=i(20),r=i(0),n=i(16),l=i(8),a=i(21),u=i(712);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class CategoryEncoding extends s.b{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return null==(t=Object(n.a)(t))?[this.numTokens]:"oneHot"===this.outputMode&&1!==t[t.length-1]?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return Object(r.Af)(()=>{let i;if("int32"!==(t=Object(n.b)(t)).dtype&&(t=a.c(t,"int32")),void 0!==e.countWeights){if("count"!==this.outputMode)throw new l.e("countWeights is not used when outputMode !== count.\n              Received countWeights="+e.countWeights);i=Object(n.b)(e.countWeights)}const s=Object(r.ze)(t),o=Object(r.Fe)(t),c=Object(r.me)(this.numTokens,s).bufferSync().get(0),h=Object(r.ne)(o,0).bufferSync().get(0);if(!c||!h)throw new l.e("Input values must be between 0 < values <= numTokens with numTokens="+this.numTokens);return u.a(t,this.outputMode,this.numTokens,i)})}}CategoryEncoding.className="CategoryEncoding",r.df.registerClass(CategoryEncoding)},712:function(t,e,i){"use strict";i.d(e,"a",(function(){return a}));var s=i(0),r=i(16),n=i(8),l=i(21);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function a(t,e,i,a){let u=Object(r.b)(t);if("int32"!==u.dtype&&(u=l.c(u,"int32")),"int"===e)return u;const o=u.shape;if(0===u.rank&&(u=Object(s.ge)(u,-1)),"oneHot"===e&&1!==u.shape[u.shape.length-1]&&(u=Object(s.ge)(u,-1)),u.rank>2)throw new n.e(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${o} which would result in output rank ${u.rank}.`);const c=["multiHot","oneHot"].includes(e),h=u;let p;if(p=void 0!==a&&"count"===e?Object(s.Vd)(h,a,i,c):Object(s.Vd)(h,[],i,c),"tfIdf"!==e)return p;if(a)return Object(s.Ie)(p,a);throw new n.e("When outputMode is 'tfIdf', weights must be provided.")}},713:function(t,e,i){"use strict";i.d(e,"a",(function(){return Resizing}));var s=i(0),r=i(20),n=i(8),l=i(16);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const a=new Set(["bilinear","nearest"]);class Resizing extends r.b{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation){if(!a.has(t.interpolation))throw new n.e(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);this.interpolation=t.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){const e=(t=Object(l.a)(t))[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return Object(s.Af)(()=>{const e=[this.height,this.width];if("bilinear"===this.interpolation)return s.oe.resizeBilinear(t,e,!this.cropToAspectRatio);if("nearest"===this.interpolation)return s.oe.resizeNearestNeighbor(t,e,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...a]} are supported`)})}}Resizing.className="Resizing",s.df.registerClass(Resizing)},96:function(t,e,i){"use strict";i.d(e,"a",(function(){return n}));var s=i(0),r=i(12);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function n(t,e={},i=!1){return Object(r.g)(t,s.df.SerializationMap.getMap().classNameMap,e,"layer",i)}}}]);