(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{188:function(n,e,t){"use strict";t.d(e,"a",(function(){return Conv2DDerFilterProgram})),t.d(e,"b",(function(){return Conv2DDerInputProgram})),t.d(e,"c",(function(){return Conv3DDerFilterProgram})),t.d(e,"d",(function(){return Conv3DDerInputProgram}));
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Conv2DDerFilterProgram{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;const e=n.strideHeight,t=n.strideWidth,o=n.padInfo.top,i=n.padInfo.left,r="channelsLast"===n.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${o};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${t} - ${i};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              if (${r}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Conv2DDerInputProgram{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,t=n.filterWidth,o=n.strideHeight,i=n.strideWidth,r="channelsLast"===n.dataFormat,a=e-1-n.padInfo.top,s=t-1-n.padInfo.left,d=r?1:2,x=r?2:3,C=r?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${C}];\n\n        ivec2 dyCorner = ivec2(coords[${d}], coords[${x}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${o}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${t}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${t} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Conv3DDerFilterProgram{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;const e=n.strideDepth,t=n.strideHeight,o=n.strideWidth,i=n.padInfo.front,r=n.padInfo.top,a=n.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${e} - ${i};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${t} - ${r};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${o} - ${a};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Conv3DDerInputProgram{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterDepth,t=n.filterHeight,o=n.filterWidth,i=n.strideDepth,r=n.strideHeight,a=n.strideWidth,s=e-1-n.padInfo.front,d=t-1-n.padInfo.top,x=o-1-n.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${s}, ${d}, ${x});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${i}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${t}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${r}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${t} - 1 - wR;\n\n            for (int wC = 0; wC < ${o}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${o} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},204:function(n,e,t){"use strict";t.d(e,"a",(function(){return o})),t.d(e,"b",(function(){return CumProgram}));var o,i=t(40);!function(n){n.Prod="*",n.Sum="+"}(o||(o={}));class CumProgram{constructor(n,e,t,s){this.op=n,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const d=this.outputShape.length,x=this.op===o.Prod?"1.0":"0.0",C=t?x:`getX(${r(d,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";t?(c=s?"end != "+(l-1):"end != 0",u=s?"end + 1":"end - 1"):(c=s?"end + pow2 < "+l:"end >= pow2",u=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Object(i.a)(d)} coords = getOutputCoords();\n        int end = ${a(d,"coords",this.op)};\n        float val = ${C};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${u};\n          ${a(d,"coords",this.op)} = idx;\n          val ${this.op}= getX(${r(d,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function r(n,e,t){if(1===n)return""+e;if(2===n)return`${e}.x, ${e}.y`;if(3===n)return`${e}.x, ${e}.y, ${e}.z`;if(4===n)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function a(n,e,t){if(1===n)return""+e;if(2===n)return e+".y";if(3===n)return e+".z";if(4===n)return e+".w";throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}},248:function(n,e,t){"use strict";t.d(e,"a",(function(){return Conv2DProgram})),t.d(e,"b",(function(){return Conv3DProgram}));
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Conv2DProgram{constructor(n,e=!1,t=null,o=!1,i=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const r=n.padInfo.top,a=n.padInfo.left,s=n.strideHeight,d=n.strideWidth,x=n.dilationHeight,C=n.dilationWidth,l=n.filterHeight,c=n.filterWidth,u=4*Math.floor(n.inChannels/4),f=n.inChannels%4,$="channelsLast"===n.dataFormat,h=$?1:2,v=$?2:3,y=$?3:1;let w="",R="";t&&(w=o?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${t}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${t}\n        }`:`\n          float activation(float x) {\n            ${t}\n          }\n        `,R="result = activation(result);");const p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${w}\n\n      const ivec2 strides = ivec2(${s}, ${d});\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${h}], coords[${v}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l}; wR++) {\n          int xR = xRCorner + wR * ${x};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${c}; wC++) {\n            int xC = xCCorner + wC * ${C};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${u}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${$}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${$}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${u}) *\n                    getW(wR, wC, ${u}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${u}, xR, xC) *\n                    getW(wR, wC, ${u}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${u}, d2),\n                getW(wR, wC, ${u} + 1, d2)\n              );\n\n              if (${$}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${u}),\n                  getX(batch, xR, xC, ${u} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${u}, xR, xC),\n                  getX(batch, ${u} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${u}, d2),\n                getW(wR, wC, ${u} + 1, d2),\n                getW(wR, wC, ${u} + 2, d2)\n              );\n\n              if (${$}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${u}),\n                  getX(batch, xR, xC, ${u} + 1),\n                  getX(batch, xR, xC, ${u} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${u}, xR, xC),\n                  getX(batch, ${u} + 1, xR, xC),\n                  getX(batch, ${u} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${p}\n        ${R}\n        setOutput(result);\n      }\n    `}}class Conv3DProgram{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const e=n.padInfo.front,t=n.padInfo.top,o=n.padInfo.left,i=n.strideDepth,r=n.strideHeight,a=n.strideWidth,s=n.dilationDepth,d=n.dilationHeight,x=n.dilationWidth,C=n.filterDepth,l=n.filterHeight,c=n.filterWidth,u=4*Math.floor(n.inChannels/4),f=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${r}, ${a});\n      const ivec3 pads = ivec3(${e}, ${t}, ${o});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${C}; wF++) {\n          int xF = xFCorner + wF * ${s};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${l}; wR++) {\n            int xR = xRCorner + wR * ${d};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${c}; wC++) {\n              int xC = xCCorner + wC * ${x};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${u}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${u}) *\n                  getW(wF, wR, wC, ${u}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${u}),\n                  getX(batch, xF, xR, xC, ${u} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${u}, d2),\n                  getW(wF, wR, wC, ${u} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${u}),\n                  getX(batch, xF, xR, xC, ${u} + 1),\n                  getX(batch, xF, xR, xC, ${u} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${u}, d2),\n                  getW(wF, wR, wC, ${u} + 1, d2),\n                  getW(wF, wR, wC, ${u} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},397:function(n,e,t){"use strict";t.d(e,"a",(function(){return Conv2DPackedProgram}));var o=t(0),i=t(51);
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Conv2DPackedProgram{constructor(n,e=!1,t=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Object(i.e)(this.outputShape.length);const s=n.padInfo.left,d=n.strideWidth,x=n.dilationWidth,C=n.filterHeight,l=n.filterWidth,c=l;let u="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let n=0;n<l;n++)u+=`\n           vec4 xTexelC${2*n};\n           int xTexelC${2*n}Ready;\n           vec4 xTexelC${2*n+1};\n           int xTexelC${2*n+1}Ready;\n           vec4 xC${n};`;u+=`\n     for (int r = 0; r < ${C}; r++) {\n      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {\n       `;for(let n=0;n<l;n++)u+=`\n           xTexelC${2*n} = vec4(0.0);\n           xTexelC${2*n}Ready = 0;\n           xTexelC${2*n+1} = vec4(0.0);\n           xTexelC${2*n+1}Ready = 0;\n           xC${n} = vec4(0.0);`;u+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let e=0;e<(c+1)/2;e++){const t=2*e;if(u+=`\n           xC = xCCorner + ${t*x};\n           `,1===d){if(t<l&&(s%2==1?(u+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,u+=1===x&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):u+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<l)){const n=s%2==0?o.Hf.nearestLargerEven(x):x;x%2==0&&s%2==1||x%2!=0&&s%2!=1?(u+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${n};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,u+=x>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):u+=1===n?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${n};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<l&&(s%2==1?(u+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<l&&(u+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(u+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<l&&(u+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<l&&(u+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${n.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<l&&(u+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${n.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}u+="\n     }\n   ",u+="\n     }\n   ",u+="\n     }\n   ";let f="",$="";t&&(f=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${t}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${t}\n         }`:`vec4 activation(vec4 x) {\n           ${t}\n         }`,$="result = activation(result);");const h=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${f}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${u}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${h}\n         ${$}\n         setOutput(result);\n       }\n     `}}},399:function(n,e,t){"use strict";t.d(e,"a",(function(){return DepthwiseConvPacked2DProgram}));var o=t(0),i=t(51);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class DepthwiseConvPacked2DProgram{constructor(n,e=!1,t=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Object(i.e)(this.outputShape.length);const s=n.outChannels/n.inChannels,d=n.padInfo.left,x=n.strideWidth,C=n.dilationWidth,l=n.filterHeight,c=n.filterWidth,u=c;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let n=0;n<c;n++)f+=`\n          vec4 xTexelC${2*n};\n          int xTexelC${2*n}Ready;\n          vec4 xTexelC${2*n+1};\n          int xTexelC${2*n+1}Ready;\n          vec4 xC${n};`;f+=`\n    for (int r = 0; r < ${l}; r++) {\n      `;for(let n=0;n<c;n++)f+=`\n          xTexelC${2*n} = vec4(0.0);\n          xTexelC${2*n}Ready = 0;\n          xTexelC${2*n+1} = vec4(0.0);\n          xTexelC${2*n+1}Ready = 0;\n          xC${n} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let n=0;n<(u+1)/2;n++){const e=2*n;if(f+=`\n          xC = xCCorner + ${e*C};\n          `,1===x){if(e<c&&(d%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,f+=1===C&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const n=d%2==0?o.Hf.nearestLargerEven(C):C;C%2==0&&d%2==1||C%2!=0&&d%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${n};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,f+=C>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):f+=1===n?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${n};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(d%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(f+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(f+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(f+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let $="",h="";t&&($=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${t}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${t}\n        }`:`vec4 activation(vec4 x) {\n          ${t}\n        }`,h="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${$}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${v}\n        ${h}\n        setOutput(result);\n      }\n    `}}},400:function(n,e,t){"use strict";t.d(e,"a",(function(){return DepthwiseConv2DProgram}));var o=t(51);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DepthwiseConv2DProgram{constructor(n,e=!1,t=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Object(o.e)(this.outputShape.length);const a=n.filterHeight,s=n.filterWidth,d=n.outChannels/n.inChannels;let x="",C="";t&&(x=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${t}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${t}\n        }`:`\n          float activation(float x) {\n            ${t}\n          }\n        `,C="result = activation(result);");const l=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${d};\n        int q = d2 - d1 * ${d};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${l}\n        ${C}\n        setOutput(result);\n      }\n    `}}},401:function(n,e,t){"use strict";t.d(e,"a",(function(){return DepthwiseConv2DDerFilterProgram})),t.d(e,"b",(function(){return DepthwiseConv2DDerInputProgram}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class DepthwiseConv2DDerFilterProgram{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;const e=n.strideHeight,t=n.strideWidth,o=n.padInfo.top,i=n.padInfo.left,r=n.outChannels/n.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${r} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${o};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${t} - ${i};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class DepthwiseConv2DDerInputProgram{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,t=n.filterWidth,o=n.strideHeight,i=n.strideWidth,r=e-1-n.padInfo.top,a=t-1-n.padInfo.left,s=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${o}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${t}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${t} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},939:function(n,e,t){"use strict";t.d(e,"a",(function(){return ConcatPackedProgram}));var o=t(0),i=t(60),r=t(40);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ConcatPackedProgram{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=o.Ad.computeOutShape(n,e);const t=this.outputShape,s=t.length,d=Object(r.a)(s),x=Object(i.a)("coords",s),C=["x","y","z","w","u","v"].slice(0,s);this.variableNames=n.map((n,e)=>"T"+e);const l=new Array(n.length-1);l[0]=n[0][e];for(let t=1;t<l.length;t++)l[t]=l[t-1]+n[t][e];const c=C[e],u=C.slice(-2),f=C.join();let $=`if (${c} < ${l[0]}) {\n        return getChannel(\n            getT0(${f}), vec2(${u.join()}));\n        }`;for(let n=1;n<l.length;n++){const e=l[n-1];$+=`\n        if (${c} < ${l[n]}  && ${c} >= ${l[n-1]}) {\n          return getChannel(\n            getT${n}(${a(C,c,e)}),\n            vec2(${a(u,c,e)}));\n        }`}const h=l.length,v=l[l.length-1];$+=`\n        return getChannel(\n          getT${h}(${a(C,c,v)}),\n          vec2(${a(u,c,v)}));`,this.userCode=`\n      float getValue(${C.map(n=>"int "+n)}) {\n        ${$}\n      }\n\n      void main() {\n        ${d} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${x}), 0., 0., 0.);\n\n        ${x[s-1]} = ${x[s-1]} + 1;\n        if (${x[s-1]} < ${t[s-1]}) {\n          result.g = getValue(${x});\n        }\n\n        ${x[s-2]} = ${x[s-2]} + 1;\n        if (${x[s-2]} < ${t[s-2]}) {\n          result.a = getValue(${x});\n        }\n\n        ${x[s-1]} = ${x[s-1]} - 1;\n        if (${x[s-2]} < ${t[s-2]} &&\n            ${x[s-1]} < ${t[s-1]}) {\n          result.b = getValue(${x});\n        }\n        setOutput(result);\n      }\n    `}}function a(n,e,t){const o=n.indexOf(e);return n.map((n,e)=>e===o?`${n} - ${t}`:n).join()}},940:function(n,e,t){"use strict";t.d(e,"a",(function(){return ConcatProgram}));var o=t(0);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ConcatProgram{constructor(n){this.outputShape=[],this.outputShape=o.Ad.computeOutShape(n,1),this.variableNames=n.map((n,e)=>"T"+e);const e=new Array(n.length-1);e[0]=n[0][1];for(let t=1;t<e.length;t++)e[t]=e[t-1]+n[t][1];const t=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let n=1;n<e.length;n++){const o=e[n-1];t.push(`else if (yC < ${e[n]}) setOutput(getT${n}(yR, yC-${o}));`)}const i=e.length,r=e[e.length-1];t.push(`else setOutput(getT${i}(yR, yC-${r}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${t.join("\n        ")}\n      }\n    `}}},951:function(n,e,t){"use strict";t.d(e,"a",(function(){return CropAndResizeProgram}));
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class CropAndResizeProgram{constructor(n,e,t,o,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[r,a,s,d]=n,[x]=e,[C,l]=t;this.outputShape=[x,C,l,d];const c="bilinear"===o?1:0,[u,f]=[a-1+".0",s-1+".0"],[$,h,v]=C>1?[""+(a-1)/(C-1),"(y2-y1) * height_ratio",`y1*${u} + float(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+u],[y,w,R]=l>1?[""+(s-1)/(l-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+f];this.userCode=`\n      const float height_ratio = float(${$});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${r}) {\n          return;\n        }\n\n        float height_scale = ${h};\n        float width_scale = ${w};\n\n        float in_y = ${v};\n        if( in_y < 0.0 || in_y > ${u} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${R};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${c} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}}}]);