(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{246:function(e,t,n){"use strict";n.d(t,"a",(function(){return GPGPUContext}));var r=n(0),i=n(97),o=n(67),s=n(33),a=n(13);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class GPGPUContext{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Object(r.de)().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,Object(i.b)(t,e)):this.gl=Object(i.a)(t),e=this.gl,2===Object(r.de)().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>a.e(t,()=>t.createVertexArray()),this.bindVertexArray=e=>a.e(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>a.e(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>a.e(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>a.e(e,()=>t.createVertexArrayOES()),this.bindVertexArray=n=>a.e(e,()=>t.bindVertexArrayOES(n)),this.deleteVertexArray=n=>a.e(e,()=>t.deleteVertexArrayOES(n)),this.getVertexArray=()=>a.e(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Object(r.de)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=a.o(this.gl,e),a.x(this.gl,t))this.textureHalfFloatExtension=a.o(this.gl,t);else if(Object(r.de)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),a.x(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=a.o(this.gl,"EXT_color_buffer_half_float");else if(Object(r.de)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",a.x(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!a.x(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=o.i(this.gl),this.indexBuffer=o.f(this.gl),this.framebuffer=a.h(this.gl),this.textureConfig=s.g(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(r.de)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;a.e(e,()=>e.finish()),a.e(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),a.e(e,()=>e.deleteFramebuffer(this.framebuffer)),a.e(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),a.e(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),a.e(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),o.e(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),o.c(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),o.h(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),o.u(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),o.t(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),o.d(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),o.g(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(a.F(this.gl,this.framebuffer),this.outputTexture=null),a.e(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>o.k(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,i,s){return o.n(this.gl,e,t,n,r,i,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return o.l(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=o.b(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Object(r.de)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(i,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=i}else Object(r.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Object(r.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>o.m(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=o.j(t));const n=a.i(t);let r;return a.e(t,()=>t.attachShader(n,this.vertexShader)),a.e(t,()=>t.attachShader(n,e)),a.D(t,n),r=Object.assign(n,{vao:this.createVertexArray()}),this.bindVertexArray(r.vao),a.e(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(o.a(t,r,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&a.H(t,r),this.setProgram(r),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(a.e(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&a.H(this.gl,this.program)),a.e(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?a.r(this.gl,e,t):a.q(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),a.e(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),a.c(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,i]=s.e(t,n);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&a.H(this.gl,this.program),a.G(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}a.e(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),a.e(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=a.o(this.gl,2===Object(r.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Object(r.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Object(r.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await r.Hf.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,Object(r.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Object(r.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n=void 0;"setTimeoutCustom"in Object(r.de)().platform&&(n=Object(r.de)().platform.setTimeoutCustom.bind(Object(r.de)().platform)),r.Hf.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),a.b(this.gl,e,this.framebuffer),this.debug&&a.G(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(a.b(this.gl,this.outputTexture,this.framebuffer),this.debug&&a.G(this.gl)):a.F(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;a.b(r,e,this.framebuffer),this.debug&&a.G(r),this.outputTexture=e,a.e(r,()=>r.viewport(0,0,t,n)),a.e(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),a.e(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}},439:function(e,t,n){"use strict";var r=n(554);n.d(t,"a",(function(){return r.a}));n(1261);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},51:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return a})),n.d(t,"d",(function(){return l})),n.d(t,"c",(function(){return f})),n.d(t,"e",(function(){return c}));var r=n(0),i=n(40),o=n(13);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s(e,t,n,s){const u=n.map((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),l=u.map(e=>e.shapeInfo),f={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},c=i.c(u,f,t),h=Object(o.g)(e.gl,c),d=e.createProgram(h);return Object(r.de)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:h,source:c,webGLProgram:d,inShapeInfos:l,outShapeInfo:f,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:h,source:c,webGLProgram:d,inShapeInfos:l,outShapeInfo:f},a(e,t,d))}function a(e,t,n){const i={},o={},s={},a=[];let u,l,f,c=null,h=null;h=e.getUniformLocation(n,"NAN",!1),1===Object(r.de)().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));for(let r=0;r<t.variableNames.length;r++){const a=t.variableNames[r];i[a]=e.getUniformLocation(n,a,!1),i["offset"+a]=e.getUniformLocation(n,"offset"+a,!1),t.enableShapeUniforms&&(o[a+"Shape"]=e.getUniformLocation(n,a+"Shape",!1),s[a+"TexShape"]=e.getUniformLocation(n,a+"TexShape",!1))}return t.enableShapeUniforms&&(u=e.getUniformLocation(n,"outShape",!1),f=e.getUniformLocation(n,"outShapeStrides",!1),l=e.getUniformLocation(n,"outTexShape",!1)),t.customUniforms&&t.customUniforms.forEach((t,r)=>{a[r]=e.getUniformLocation(n,t.name,!1)}),{uniformLocations:i,customUniformLocations:a,infLoc:c,nanLoc:h,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:u,outShapeStridesLocation:f,outTexShapeLocation:l}}function u(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const i=e.logicalShape,o=t[n],s=o.shape;if(!r.Hf.arraysEqual(i,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${s} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,u=o.isUniform?null:o.texData.texShape;if(!r.Hf.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function l(e,t,n,o,s){t.program.enableShapeUniforms||(u(t.inShapeInfos,n),u([t.outShapeInfo],[o]));const a=o.texData.texture,l=o.texData.texShape;o.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,l[0],l[1]):e.setOutputMatrixTexture(a.texture,l[0],l[1]),e.setProgram(t.webGLProgram),1===Object(r.de)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,o)=>{const s=t.program.variableNames[o],a=t.uniformLocations[s],u=t.uniformLocations["offset"+s],l=t.inShapesLocations[s+"Shape"],f=t.inTexShapesLocations[s+"TexShape"];if(l){const{uniformShape:r}=i.b(t.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(l,new Int32Array(r));break;case 2:e.gl.uniform2iv(l,new Int32Array(r));break;case 3:e.gl.uniform3iv(l,new Int32Array(r));break;case 4:e.gl.uniform4iv(l,new Int32Array(r))}}if(f&&e.gl.uniform2i(f,n.texData.texShape[0],n.texData.texShape[1]),null!=a)if(n.isUniform)if(r.Hf.sizeFromShape(n.shape)<2)e.gl.uniform1f(a,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=n.texData.slice&&null!=u&&e.gl.uniform1i(u,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture.texture,a,o)});const f=t.outShapeLocation;if(f)switch(o.shape.length){case 1:e.gl.uniform1iv(f,new Int32Array(o.shape));break;case 2:e.gl.uniform2iv(f,new Int32Array(o.shape));break;case 3:e.gl.uniform3iv(f,new Int32Array(o.shape));break;case 4:e.gl.uniform4iv(f,new Int32Array(o.shape))}if(t.outShapeStridesLocation){const n=r.Hf.computeStrides(o.shape);switch(o.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,o.texData.texShape[0],o.texData.texShape[1]),t.program.customUniforms&&s&&t.program.customUniforms.forEach((n,r)=>{const i=t.customUniformLocations[r],o=s[r];if("float"===n.type)e.gl.uniform1fv(i,o);else if("vec2"===n.type)e.gl.uniform2fv(i,o);else if("vec3"===n.type)e.gl.uniform3fv(i,o);else if("vec4"===n.type)e.gl.uniform4fv(i,o);else if("int"===n.type)e.gl.uniform1iv(i,o);else if("ivec2"===n.type)e.gl.uniform2iv(i,o);else if("ivec3"===n.type)e.gl.uniform3iv(i,o);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(i,o)}}),e.executeProgram()}function f(e,t,n){let o="";t.concat(n).forEach(t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:u,uniformShape:l,keptDims:f}=i.b(e.packedInputs,t.shape,a);let c="",h="",d="";if(1===l.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];c=`${e[0]>1}_${e[1]>1}`}else if(2!==l.length||e.packedInputs){if(l.length>2&&!e.packedInputs){const e=r.Hf.computeStrides(l);d=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else h=`${l[0]>1}_${l[1]>1}`;const m=t.shape.length,g=2===l.length&&r.Hf.arraysEqual(t.shape,a),p=1===r.Hf.sizeFromShape(t.shape),E=r.Ad.getBroadcastDims(t.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&r.Hf.arraysEqual(a,n.texData.texShape),_=e.packedInputs||l.length>2?"":`${a[0]>1}_${a[1]>1}`;o+=`${m}_${x}_${u?f:""}_${l.length}_${p}_${E}_${g}_${c}_${h}_${d}_${_}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;o+=`${t.shape}_${e}_${s}`}});const s=e.userCode;let a=e.constructor.name;return a+="_"+o+"_"+s+Object(r.de)().getNumber("WEBGL_VERSION"),a}function c(e){return Object(r.de)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}},62:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n(0);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i(){let e,t,n,i,o,s,a,u,l,f;return 2===Object(r.de)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",i="in",o="texture",s="outputColor",a="out vec4 outputColor;",u=Object(r.de)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",f="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",i="varying",o="texture2D",s="gl_FragColor",a="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",f="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:i,texture2D:o,output:s,defineOutput:a,defineSpecialNaN:u,defineSpecialInf:l,defineRound:f}}},67:function(e,t,n){"use strict";n.d(t,"j",(function(){return a})),n.d(t,"i",(function(){return u})),n.d(t,"f",(function(){return l})),n.d(t,"q",(function(){return c})),n.d(t,"e",(function(){return h})),n.d(t,"o",(function(){return d})),n.d(t,"c",(function(){return m})),n.d(t,"s",(function(){return g})),n.d(t,"h",(function(){return p})),n.d(t,"r",(function(){return E})),n.d(t,"g",(function(){return x})),n.d(t,"p",(function(){return _})),n.d(t,"d",(function(){return T})),n.d(t,"a",(function(){return b})),n.d(t,"t",(function(){return S})),n.d(t,"u",(function(){return I})),n.d(t,"b",(function(){return v})),n.d(t,"l",(function(){return R})),n.d(t,"k",(function(){return D})),n.d(t,"n",(function(){return y})),n.d(t,"m",(function(){return L}));var r=n(0),i=n(62),o=n(33),s=n(13);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function a(e){const t=Object(i.a)(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return s.m(e,n)}function u(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return s.k(e,t)}function l(e){const t=new Uint16Array([0,1,2,2,1,3]);return s.j(e,t)}function f(e,t,n,i,o,a){s.I(t,n);const u=s.l(e),l=e.TEXTURE_2D;return s.e(e,()=>e.bindTexture(l,u)),s.e(e,()=>e.texParameteri(l,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),s.e(e,()=>e.texParameteri(l,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),s.e(e,()=>e.texParameteri(l,e.TEXTURE_MIN_FILTER,e.NEAREST)),s.e(e,()=>e.texParameteri(l,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===Object(r.de)().getNumber("WEBGL_VERSION")?s.e(e,()=>e.texImage2D(l,0,i,t,n,0,o,a,null)):s.e(e,()=>e.texStorage2D(l,1,i,t,n)),s.e(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:u,texShape:[n,t]}}function c(e){return e.internalFormatFloat}function h(e,t,n,r){const[i,s]=o.i(t,n);return f(e,i,s,c(r),r.textureFormatFloat,e.FLOAT)}function d(e){return e.internalFormatHalfFloat}function m(e,t,n,r){const[i,s]=o.i(t,n);return f(e,i,s,d(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function g(e){return e.downloadTextureFormat}function p(e,t,n,r){const[i,s]=o.i(t,n);return f(e,i,s,g(r),e.RGBA,e.UNSIGNED_BYTE)}function E(e){return e.internalFormatPackedFloat}function x(e,t,n,r){const[i,s]=o.e(t,n);return f(e,i,s,E(r),e.RGBA,e.FLOAT)}function _(e){return e.internalFormatPackedHalfFloat}function T(e,t,n,r){const[i,s]=o.e(t,n);return f(e,i,s,_(r),e.RGBA,r.textureTypeHalfFloat)}function b(e,t,n){s.e(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n));return s.d(e,t,"clipSpacePos",n,3,20,0)&&s.d(e,t,"uv",n,2,20,12)}function S(e,t,n,i,o,a){let u,l,f;s.e(e,()=>e.bindTexture(e.TEXTURE_2D,t)),o instanceof Uint8Array?(u=new Uint8Array(n*i*4),l=e.UNSIGNED_BYTE,f=e.RGBA):(u=new Float32Array(n*i*4),l=e.FLOAT,f=a.internalFormatPackedFloat),u.set(o),2===Object(r.de)().getNumber("WEBGL_VERSION")?s.e(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,i,e.RGBA,l,u)):s.e(e,()=>e.texImage2D(e.TEXTURE_2D,0,f,n,i,0,e.RGBA,l,u)),s.e(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function I(e,t,n){s.e(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?2===Object(r.de)().getNumber("WEBGL_VERSION")?s.e(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):s.e(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):2===Object(r.de)().getNumber("WEBGL_VERSION")?s.e(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):s.e(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),s.e(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function v(e,t,n,r){const i=e.createBuffer();s.e(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,i));const o=16*t*n;return s.e(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)),s.e(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),s.e(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),i}function R(e,t,n){const r=e,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function D(e,t,n,r){const[i,a]=o.i(t,n),u=new Uint8Array(o.h(t*n,4));return s.e(e,()=>e.readPixels(0,0,i,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,u)),new Float32Array(u.buffer)}function y(e,t,n,r,i,s,a,u){const l=e,f=new Float32Array(o.f(s,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,f),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),f}function L(e,t,n){const r=new Float32Array(t*n*4);return s.e(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}},942:function(e,t,n){"use strict";n.d(t,"a",(function(){return Im2ColPackedProgram}));var r=n(62),i=n(51);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Im2ColPackedProgram{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Object(i.e)(this.outputShape.length);const{dataFormat:n}=t,o=Object(r.a)(),s="channelsLast"===n,a=s?1:2,u=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let f="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)f+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${u}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${f}\n\n        ${o.output} = result;\n      }\n    `}}},973:function(e,t,n){"use strict";n.d(t,"a",(function(){return FlipLeftRightProgram}));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class FlipLeftRightProgram{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}},982:function(e,t,n){"use strict";n.d(t,"a",(function(){return GatherNDProgram}));var r=n(40);class GatherNDProgram{constructor(e,t,n,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=n;const o=Object(r.a)(n.length);let s="\n    int index;";for(let e=0;e<this.sliceDim;e++)s+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}},983:function(e,t,n){"use strict";n.d(t,"a",(function(){return GatherProgram}));var r=n(40);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GatherProgram{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Object(r.a)(this.rank),i=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("index"):r.push(""+n[t]);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${i}));\n      }\n    `}}}}]);