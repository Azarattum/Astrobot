(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{355:function(e,t,n){"use strict";n.d(t,"a",(function(){return MathBackendWebGL}));n(1260);var a=n(0),s=n(97),i=n(891),o=n(890),r=n(887),d=n(886),c=n(457),u=n(892),h=n(246),l=n(51),p=n(18),g=n(889),f=n(391),m=n(33),x=n(885),y=n(38),b=n(84),I=n(888),C=n(13);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const w=a.re.whereImpl,O={};const P=Object(a.de)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class MathBackendWebGL extends a.yb{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Object(a.de)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof h.a)t=e;else{const n=Object(s.a)(Object(a.de)().getNumber("WEBGL_VERSION"),e);t=new h.a(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=Object(s.a)(Object(a.de)().getNumber("WEBGL_VERSION"));t=new h.a(e),this.binaryCache=((n=Object(a.de)().getNumber("WEBGL_VERSION"))in O||(O[n]={}),O[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new x.a(this.gpgpu),this.numMBBeforeWarning=null==Object(a.de)().global.screen?1024:Object(a.de)().global.screen.height*Object(a.de)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new a.N(this,Object(a.ce)())}nextDataId(){return MathBackendWebGL.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,s,i){const o=this.makeTensorInfo(t,n),r=this.texData.get(o.dataId);r.isPacked=!1,r.texture={texture:e,texShape:[a,s]},r.texShape=[a,s];const d=C.t(t),u=new c.a(d,!1,i),h=this.runWebGLProgram(u,[o],n,[[a,s]]);return h.shape=t,r.texture=null,this.disposeIntermediateTensorInfo(o),h.dataId}write(e,t,n){if((Object(a.de)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(a.de)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:n,values:e,usage:m.c.UPLOAD,refCount:1}),s}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,s,i){if(Object(a.de)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:s,values:t,usage:m.c.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:s,complexTensorInfos:i,slice:o,shape:r,isPacked:d}=t;if(null!=o){let t;t=d?new b.f(r,y.c):new y.i(r,y.c);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===s)return n;const c=null!=this.activeTimers;let u,h;if(c&&(u=a.Hf.now()),"complex64"===s){const e=this.readSync(i.real.dataId),t=this.readSync(i.imag.dataId);h=a.Ad.mergeRealAndImagArrays(e,t)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=a.Hf.now()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}const t=this.texData.get(e),{values:n,shape:s,slice:i,dtype:o,complexTensorInfos:r,isPacked:d}=t;if(null!=i){let t;t=d?new b.f(s,y.c):new y.i(s,y.c);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:o}],o),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(Object(a.de)().getBool("DEBUG")&&!Object(a.de)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Object(a.de)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,u,h=null;if("complex64"!==o&&Object(a.de)().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);h=this.gpgpu.createBufferFromTexture(t.texture.texture,...m.d(s))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const e=await Promise.all([this.read(r.real.dataId),this.read(r.imag.dataId)]),t=e[0],n=e[1];u=a.Ad.mergeRealAndImagArrays(t,n)}else if(null==h)u=this.getValuesFromTexture(e);else{const e=a.Hf.sizeFromShape(s);u=this.gpgpu.downloadFloat32MatrixFromBuffer(h,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=h){const e=this.gpgpu.gl;C.e(e,()=>e.deleteBuffer(h))}const l=this.convertAndCacheOnCPU(e,u),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(e=>e(l)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Object(a.ce)().removeDataId(e,this),this.pendingDeletes--),l}readToGPU(e,t={}){const n=this.texData.get(e),{values:s,shape:i,slice:o,dtype:r,isPacked:d,texture:c}=n;if("complex64"===r)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let n;n=d?new b.f(i,y.c):new y.i(i,y.c);const a=this.runWebGLProgram(n,[{dataId:e,shape:i,dtype:r}],r),s=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),s}if(null==c)throw null!=s?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),h=Object(a.ce)().makeTensorFromTensorInfo(u),l=this.texData.get(u.dataId);return Object.assign({tensorRef:h},l.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>a.Hf.decodeString(e));return Object(a.Hd)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(a.Hd)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!C.f(n)){if(Object(a.de)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:s}=this.texData.get(e),i=a.Hf.sizeFromShape(t);if(Object(a.de)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...m.d(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(n),s}const o=Object(a.de)().getBool("WEBGL_PACK")&&!0===s,c=o?C.t(t):t,u=o?new d.a(c):new r.a(c),h=this.runWebGLProgram(u,[{shape:c,dtype:n,dataId:e}],"float32"),l=this.texData.get(h.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(h),p}timerAvailable(){return Object(a.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,e();const i=a.Hf.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),o=a.Hf.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,s&&(this.programTimersStack=null);const r={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Object(a.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(i);r.kernelMs=a.Hf.sum(e),r.getExtraProfileInfo=()=>e.map((e,t)=>({name:o[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else r.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,r})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(a.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:a.Hf.now(),endMs:null}}endTimer(e){return Object(a.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=a.Hf.now(),e)}async getQueryTime(e){if(Object(a.de)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:s,isPacked:i,slice:o}=this.texData.get(e),r=o&&o.origDataId||e,d=this.dataRefCount.get(r);d>1?this.dataRefCount.set(r,d-1):(this.dataRefCount.delete(r),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,s,i)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=P){return Object(a.de)().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&a.Hf.sizeFromShape(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){a.Ad.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return w(e.shape,t)}packedUnaryOp(e,t,n){const s=new b.f(e.shape,t),i=this.compileAndRun(s,[e],n);return Object(a.ce)().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Object(p.G)(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Object(a.de)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,y.a,e.dtype);const t=new y.i(e.shape,y.a),n=this.compileAndRun(t,[e]);return Object(a.ce)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&a.Hf.isString(n[0])){const i=n.map(e=>a.Hf.encodeString(e));s=this.write(i,e,t)}else s=this.write(n,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,n){return Object(a.ce)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new I.a(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new g.a(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[C.n(e.shape),...C.s(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},s=[C.n(t),...C.s(t)],i=new f.a(s,n),o=[n],r=this.runWebGLProgram(i,[a],e.dtype,o,!0);return{dataId:r.dataId,shape:t,dtype:r.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:s,shape:r,dtype:d}=n;if(null!=t){const e=a.Hf.sizeFromShape(r),n=t[0]*t[1]*4;a.Hf.assert(e<=n,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const c=C.t(r);let u;u=s?new o.a(c):new i.a(c);const h=[null!=t?t:m.d(c)];return{dtype:d,shape:r,dataId:this.runWebGLProgram(u,[{shape:c,dtype:d,dataId:e}],d,h,!0,t).dataId}}runWebGLProgram(e,t,n,s,i=!1,o){const r=this.makeTensorInfo(e.outputShape,n),d=this.texData.get(r.dataId);if(e.packedOutput&&(d.isPacked=!0),e.outPackingScheme===m.a.DENSE){const t=null!=o?o:m.d(e.outputShape);d.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(d.usage=e.outTexUsage),0===a.Hf.sizeFromShape(r.shape))return d.values=a.Hf.getTypedArrayFromDType(r.dtype,0),r;const c=[],u=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&a.Hf.sizeFromShape(t.shape)<=Object(a.de)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!C.A(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(r.dataId);const h={shape:r.shape,texData:d,isUniform:!1},p=l.c(e,u,h),g=this.getAndSaveBinary(p,()=>l.a(this.gpgpu,e,u,h)),f=null!=this.activeTimers;let x;f&&(x=this.startTimer()),Object(a.de)().get("ENGINE_COMPILE_ONLY")||l.d(this.gpgpu,g,u,h,s),c.forEach(e=>this.disposeIntermediateTensorInfo(e)),f&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const y=Object(a.de)().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const e=a.Hf.now();e-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Object(a.de)().getBool("WEBGL_LAZILY_UNPACK")&&d.isPacked&&!1===i){const e=this.unpackTensor(r);return this.disposeIntermediateTensorInfo(r),e}return r}compileAndRun(e,t,n,a,s=!1){n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Object(a.de)().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Object(a.Af)(()=>{if(!Object(a.de)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Object(a.de)().getBool("DEBUG");Object(a.de)().set("DEBUG",!1);const t=this.abs(Object(a.af)(1e-8)).dataSync()[0];if(Object(a.de)().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:s,values:i,texture:o,usage:r,isPacked:d}=t;if(null!=o)return;const h=null!=this.activeTimers;let l;h&&(l=a.Hf.now());let p=t.texShape;if(null==p&&(p=C.u(n,d),t.texShape=p),null!=i){const e=C.t(n);let o,r=p[1],g=p[0];const f=i instanceof Uint8Array||i instanceof Uint8ClampedArray;!d&&f||([r,g]=m.e(p[0],p[1])),o=d?new u.a(e,f):new c.a(e,f);const x=f?[g,r]:p,y=this.makeTensorInfo(x,s),b=this.texData.get(y.dataId);b.usage=f?m.c.PIXELS:m.c.UPLOAD,b.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),r,g,i);const I=[[g,r]],w=!0,O=this.runWebGLProgram(o,[y],s,I,w),P=this.texData.get(O.dataId);t.texShape=P.texShape,t.isPacked=P.isPacked,t.usage=P.usage,Object(a.de)().get("ENGINE_COMPILE_ONLY")?this.disposeData(O.dataId):(t.texture=P.texture,t.values=null,this.texData.delete(O.dataId)),this.disposeIntermediateTensorInfo(y),h&&(this.uploadWaitMs+=a.Hf.now()-l)}else{const e=this.acquireTexture(p,r,s,d);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype "+t)}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*a.Hf.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}});e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Object(a.Ke)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw C.E(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:a,nanLoc:s,inShapesLocations:i,inTexShapesLocations:o,outShapeLocation:r,outShapeStridesLocation:d,outTexShapeLocation:c}=Object(l.b)(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=s,e.inShapesLocations=i,e.inTexShapesLocations=o,e.outShapeLocation=r,e.outShapeStridesLocation=d,e.outTexShapeLocation=c}}createTensorFromTexture(e,t,n){const{texture:s,height:i,width:o,channels:r}=e,d=Object(a.ce)().backend;if(!d.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=d.writeTexture(s,t,n,i,o,r);return Object(a.ce)().makeTensorFromDataId(c,t,n,d)}}MathBackendWebGL.nextDataId=0},394:function(e,t,n){"use strict";n.d(t,"a",(function(){return AvgPool2DBackpropProgram})),n.d(t,"b",(function(){return AvgPool3DBackpropProgram}));
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AvgPool2DBackpropProgram{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,o=e.dilationWidth,r=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=r-1-e.padInfo.top,u=d-1-e.padInfo.left,h=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${c}, ${u});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n            wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${d};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class AvgPool3DBackpropProgram{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,s=e.strideDepth,i=e.strideHeight,o=e.strideWidth,r=e.dilationDepth,d=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=u-1-e.padInfo.front,g=h-1-e.padInfo.top,f=l-1-e.padInfo.left,m=1/(t*n*a);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${g}, ${f});\n      const float avgMultiplier = float(${m});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n            wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${d}) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${c}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},904:function(e,t,n){"use strict";n.d(t,"a",(function(){return AddNPackedProgram}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AddNPackedProgram{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>"T"+t);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const a=this.variableNames.map(e=>"v"+e).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}}},905:function(e,t,n){"use strict";n.d(t,"a",(function(){return AddNProgram}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AddNProgram{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>"T"+t);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const a=this.variableNames.map(e=>"v"+e).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}}},909:function(e,t,n){"use strict";n.d(t,"a",(function(){return ArgMinMaxProgram}));
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ArgMinMaxProgram{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:s,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];const o="max"===t?">":"<",r=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${r};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}},910:function(e,t,n){"use strict";n.d(t,"a",(function(){return ArgMinMaxPackedProgram}));var a=n(0),s=n(60),i=n(40);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ArgMinMaxPackedProgram{constructor(e,t,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,a.Hf.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const r=e[e.length-1],d=Math.ceil(r/t);this.outputShape=e.slice(0,-1),d>1&&this.outputShape.push(d),o||this.variableNames.push("bestIndicesA");const c=this.outputShape,u=c.length,h=Object(i.a)(u),l=Object(s.a)("coords",u);let p,g;if(1===d){g=u+1;const e=Object(i.a)(g);p=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[u-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[u-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[u-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[u-2]};`}else g=u,p=`\n        ${h} sourceLocR = coords;\n        ++${l[u-1]};\n        ${h} sourceLocG = coords;\n        ++${l[u-2]};\n        ${h} sourceLocA = coords;\n        --${l[u-1]};\n        ${h} sourceLocB = coords;\n        --${l[u-2]};`;const f=["x","y","z","w","u","v"].slice(0,g),m="."+f[g-1],x=f.map(e=>"int "+e),y=Object(s.a)("sourceLocR",g-1).concat("inIdx.r"),b=Object(s.a)("sourceLocG",g-1).concat("inIdx.g"),I=Object(s.a)("sourceLocB",g-1).concat("inIdx.b"),C=Object(s.a)("sourceLocA",g-1).concat("inIdx.a"),w="max"===n?"greaterThan":"lessThan",O=o?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${I.join()}),\n                             getBestIndicesAChannel(${C.join()})));`,P=`vec4(\n            getAChannel(${y.join()}),\n            hasNextCol ? getAChannel(${b.join()}) : 0.,\n            hasNextRow ? getAChannel(${I.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,T=o?"":`\n      float getBestIndicesAChannel(${x.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${x.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${T}\n      void main() {\n        ${h} coords = getOutputCoords();\n        bool hasNextCol = ${l[u-1]} < ${c[u-1]-1};\n        bool hasNextRow = ${l[u-2]} < ${c[u-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},\n          sourceLocB${m}, sourceLocA${m}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${P};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${O}\n          vec4 candidate = ${P};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}}}]);